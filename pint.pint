; Copyright (C) 2015  Florian Hassanen
;
; This file is part of pint.
;
; pint is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; pint is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'test' * c))
(def i (c-call LLVMInt32TypeInContext * * c))
(def ps (c-array i i))
(def ft (c-call LLVMFunctionType * * i * ps int 2 int 0))
(def f (c-call LLVMAddFunction * * m * 'plus' * ft))
(def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
(def b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * b * bb)
(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))
(c-call LLVMBuildRet void * b * r)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(if (= 0 (c-call LLVMVerifyFunction int * f int LLVMPrintMessageAction))
    nil
    (print 'error verifying function'))

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err)))

(c-call LLVMDisposeBuilder void * b)

(c-call LLVMDumpModule void * m)

(c-call LLVMLinkInMCJIT void)
(c-call ExternLLVMInitializeNativeTarget void) ; todo inlining does not work :(
(c-call ExternLLVMInitializeNativeAsmPrinter void) 

(def ee (c-ref))

(if (= 0 (c-call LLVMCreateJITCompilerForModule int * (c-ref ee) * m int 0 * (c-ref err)))
    nil
    (print (c-str err)))

(def plus (c-call LLVMGetPointerToGlobal * * ee * f))

(print 'calling ' plus)

(print '3 + 4 = ' (c-call * plus int int 3 int 4))

(print '
')

; end of poc, start of pint

(def to-list
  (fn (string)

    (def to-list^
      (fn (pos rec)
        ((fn (c) (if (= c '') () (cons c (rec (+ pos 1) rec))))
         (substr string pos 1))))

    (to-list^ 0 to-list^)))

(def OP '(') ; ) (
(def CP ')')

(def newline '
')
(def whitespace (str ' 	' newline))
(def digit '0123456789')

(def nil? (fn (w) (if w nil '')))
(def not  (fn (c) (if c nil '')))

(def and (fn (a b) (if a b a)))
(def or (fn (a b) (if a a b)))

(def empty? (fn (l) (nil? (tail l))))

(def pair
  (fn (l r)
    (cons l (cons r))))

(def unpair
 (fn (p f)
  (f (head p) (head (tail p)))))

(def fst (fn (p) (unpair p (fn (f s) f))))
(def snd (fn (p) (unpair p (fn (f s) s))))

(def uncons
 (fn (l f)
  (f (head l) (tail l))))

(def range
 (fn (l)
  (def range^
   (fn (r i i1 rec)
    (if (= i 0)
     r
     (rec (cons i1 r) i1 (+ i1 (- 1)) rec))))

  (range^ () l (+ l (- 1)) range^)))

(def reduce
  (fn (f i l)
    (def reduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (f (rec res (tail ll) rec) (head ll)))))

    (reduce^ i l reduce^)))

(def leduce
  (fn (f i l)
    (def leduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (rec (f res (head ll)) (tail ll) rec))))

    (leduce^ i l leduce^)))

(def listlen
  (fn (l)
    (leduce (fn (res i) (+ 1 res)) 0 l)))

(def strlen
  (fn (s) (listlen (to-list s))))

(def reverse
  (fn (l)
    (leduce (fn (res i) (cons i res)) () l)))

(def filter
  (fn (p l)
    (reduce 
      (fn (res i)
        (if (p i) (cons i res) res))
      ()
      l)))

(def map
  (fn (t l)
    (reduce
      (fn (res e)
        (cons (t e) res))
      ()
      l)))

(def stap
  (fn (t i l)
    (reduce
      (fn (st-res e) (unpair st-res (fn (st res) (unpair (t st e) (fn (st^ e^)
       (pair st^ (cons e^ res)))))))
      (pair i ())
      l)))

(def zip
 (fn (l r)
  (def zip^ (fn (ll rr rec)
             (if (empty? ll) ()
             (if (empty? rr) ()
             (uncons ll (fn (l-h l-t)
             (uncons rr (fn (r-h r-t)
             (cons (pair l-h r-h) (rec l-t r-t rec))))))))))
  (zip^ l r zip^)))

(def in-list
  (fn (e l)
    (not (empty? (filter (fn (i) (= i e)) l)))))   

(def in-str
  (fn (c string) (in-list c (to-list string))))

(def indexof (fn (el li)
 (def indexof^ (fn (l i rec)
  (if (empty? l)
   nil
   (uncons l (fn (h t)
    (if (= el h)
     i
     (rec t (+ i 1) rec)))))))
 (indexof^ li 0 indexof^)))

(def is-whitespace
  (fn (x) (in-str x whitespace)))
(def is-newline
  (fn (x) (in-str x newline)))
(def not-is-newline
  (fn (x) (not (is-newline x))))
(def is-digit
  (fn (x) (in-str x digit)))

(def t-ws
  (fn (x) (if (is-whitespace x) '_' x)))

(def drop-while 
  (fn (p l)
    
    (def drop-while^
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (rec (tail ll) rec)
            ll))))

    (drop-while^ l drop-while^)))

(def take-while
  (fn (p l)
    
    (def take-while^ 
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (cons (head ll) (rec (tail ll) rec))
            ()))))

    (take-while^ l take-while^)))

(def concat (fn (l r) (reduce (fn (ls el) (cons el ls)) r l)))

(def assoc 
 (fn (m k v)
  (cons k (cons v m))))

(def assocall (fn (m new-m) (concat new-m m)))

(def getk
 (fn (m k)
   (def getk^
     (fn (mm rec)
       (if (empty? mm)
         nil
         (if (= k (head mm))
            (head (tail mm))
            (rec (tail (tail mm)) rec)))))

   (getk^ m getk^)))

(print (getk () 'test') newline) ; should be nil
(def testmap (assoc (assoc (assoc () 'a' 1) 'b' 2) 'a' 3))
(print (getk testmap 'a') newline) ; should be 3
(print (getk testmap 'b') newline) ; should be 2

(def split
 (fn (count list)
  
  (def split^
   (fn (list i rec)
    (if (= i count)
     (pair () list)
     (if (empty? list)
      (pair () nil)
      (unpair (rec (tail list) (+ i 1) rec)
       (fn (h t)
        (pair (cons (head list) h) t)))))))
  
  (split^ list 0 split^)))

(def take
 (fn (count list)
  (unpair (split count list)
   (fn (h t) h))))

(def drop
 (fn (count list)
  (unpair (split count list)
   (fn (h t) t))))

(def chunk
 (fn (chunk-size list)
  (def chunk^
   (fn (list rec)
    (unpair (split 2 list)
     (fn (h t)
      (if (nil? t)
       (pair () h)
       (if (empty? t)
        (pair (cons h) nil)
        (unpair (rec t rec)
         (fn (hh tt)
          (pair (cons h hh) tt)))))))))
  (chunk^ list chunk^)))

(def parse-sym 
  (fn (cs prs)
    (def sym-char
      (fn (c) (not (in-str c (str whitespace CP OP '\';')))))

    (pair 
      (symbol (str (take-while sym-char cs)))
      (drop-while sym-char cs))))

(def digit-to-number
  (fn (d)
    (if (= d '0') 0
    (if (= d '1') 1
    (if (= d '2') 2
    (if (= d '3') 3
    (if (= d '4') 4
    (if (= d '5') 5
    (if (= d '6') 6
    (if (= d '7') 7
    (if (= d '8') 8
    (if (= d '9') 9
    nil))))))))))))

(def parse-number
  (fn (cs prs)
    (def dec (take-while is-digit cs))
    (def r   (drop-while is-digit cs))
    
    (def rr  (if (empty? r) 
               r 
               (if (= '.' (head r)) 
                (tail r)
                r)))

    (def com (take-while is-digit rr))
    (def rrr (drop-while is-digit rr))

    (def n   (fn (l) (leduce (fn (nn dd) (+ (digit-to-number dd) (* 10 nn))) 0 l)))
    (def m   (fn (l) (leduce (fn (nn dd) (* 10 nn)) 1 l)))

    (pair (+ (n dec) (* (n com) (/ (m com)))) rrr)))
    
(def err (fn (x m) (print m newline) (pair (cons nil) x)))

(def parse-list 
  (fn (cs prs)
    (def parse-list^
      (fn (ccs rec)
        
        ((fn (p)
          (if (nil? p)
            (err ccs 'unexpected eof during list')
            ((fn (t r)
              (if (nil? t) ; end of list maybe?
                (if (empty? r)
                  (err ccs 'missing end of list')
                  (if (= CP (head r))
                    (pair () (tail r))
                    (err ccs (str 'unexpected: ' (head r)))))
                ((fn (pp)
                ((fn (tt rr)
                  (pair (cons t tt) rr)
                )(head pp)(head (tail pp)))
                )(rec r rec)))
            )(head p)(head (tail p))))
        )(prs ccs prs))))

      (parse-list^ (tail cs) parse-list^)))

(def parse-string
  (fn (cs rec)
    (def pcons
      (fn (i p)
        (def f (head p))
        (def s (head (tail p)))

        (if f 
          (pair (cons i f) s)
          p)))

    (def escape 
      (fn (escape-next ccs rec)
        (if (empty? ccs)
          (err ccs 'unexpected eof during string')
          (if escape-next
            (pcons (head ccs) (rec nil (tail ccs) rec))
            (if (= '\\' (head ccs))
              (rec '' (tail ccs) rec)
              (if (= '\'' (head ccs))
                (pair () (tail ccs))
                (pcons (head ccs) (rec nil (tail ccs) rec))))))))

    (def e (escape nil (tail cs) escape))
    
    (def f (head e))
    (def s (head (tail e)))

    (pair (str f) s)))

(def parse-expr
  (fn (cs rec)
    (if (empty? cs)
      nil
      ((fn (c)
        (if (is-whitespace c) (rec (drop-while is-whitespace cs) rec)
        (if (= c ';') (rec (drop-while not-is-newline cs) rec)
        (if (= c OP) (parse-list cs rec)
        (if (= c CP) (pair nil cs)
        (if (= c '\'') (parse-string cs rec)
        (if (is-digit c) (parse-number cs rec)
        (parse-sym cs rec)
        ))))))
      )(head cs)))))


(def parse-all
  (fn (cs rec)
    ((fn (p)
    (if (nil? p)
      ()
      ((fn (t r)
        (if (nil? t)
          (cons t)
          (cons t (rec r rec)))
      )(head p)(head (tail p)))
    )
    )(parse-expr cs parse-expr))))

(def code (parse-all (to-list INPUT) parse-all))

(print code newline)

(def is-number (fn (o) (= o (+ o))))
(def is-string (fn (o) (= o (str o))))
(def is-symbol (fn (o) (= o (symbol (symbol-name o)))))
(def is-list (fn (o) (if (= o ()) o (tail o))))
(def is-fn (fn (o) (if o (not (= o o)) o)))

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'real' * c))

(def void-type (c-call LLVMVoidTypeInContext * * c))
(def i8-type (c-call LLVMInt8TypeInContext * * c))
(def i32-type (c-call LLVMInt32TypeInContext * * c))
(def i64-type (c-call LLVMInt64TypeInContext * * c))
(def float-type (c-call LLVMFloatTypeInContext * * c))
(def double-type (c-call LLVMDoubleTypeInContext * * c))
(def pointer-type (c-call LLVMPointerType * * i8-type int 0))

(def value-type (c-call LLVMStructCreateNamed * * c * 'value_type'))
(c-call LLVMStructSetBody void * value-type * (c-array i64-type i64-type) int 2 int 0)

(def value-ptr-type (c-call LLVMPointerType * * value-type int 0))

(def list-elem-type (c-call LLVMStructCreateNamed * * c * 'list_elem_type'))
(c-call LLVMStructSetBody void * list-elem-type * (c-array value-type pointer-type) int 2 int 0)

(def list-elem-ptr-type (c-call LLVMPointerType * * list-elem-type int 0))

(def frame-type (c-call LLVMStructCreateNamed * * c * 'frame_type'))
(c-call LLVMStructSetBody void
 * frame-type
 * (c-array pointer-type (c-call LLVMArrayType * * value-type int 0))
 int 2
 int 0)

(def frame-ptr-type (c-call LLVMPointerType * * frame-type int 0))

(def void-type (c-call LLVMVoidTypeInContext * * c))

(def main-f-type (c-call LLVMFunctionType * * void-type * (c-array) int 0 int 0))
(def main-f (c-call LLVMAddFunction * * m * 'main' * main-f-type))
(def main-bb (c-call LLVMAppendBasicBlockInContext * * c * main-f * 'entry'))
(def main-b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * main-b * main-bb)
;(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))

; state during code gen
; contains
;   "accumulator" (current-val)
;   symbol table for each scope
;   globals
;   a list of borrowed values from an upper scope
; 2 kinds of scope are supported:
;   scope which can freely access parent scope
;   scope which needs to explicitly borrow refs from parent scope
; supported operations
;   set/get accumulator
;   set/get symbols from sym tab or globals
;   test whether there is an upper state to borrow from (am i root?)
;   borrow value from _some_ upper parent
;   branch new state (new scope)
;   merge back

(def state-make (fn (current-value
                     parent-state    ; (direct) parent
                     borrow-ancestor ; ancestor to borrow from (maybe parent, maybe not)
                     symbol-table    ; one frame for each scope
                     borrowed-syms
                     globals)
                 (cons current-value
                 (cons parent-state
                 (cons borrow-ancestor
                 (cons symbol-table
                 (cons borrowed-syms
                 (cons globals))))))))

(def init-state (fn () (state-make nil nil nil () nil ())))

(def state-unmake (fn (s f) (uncons s (fn (cv r)
                            (uncons r (fn (pt r)
                            (uncons r (fn (ba r)
                            (uncons r (fn (st r)
                            (uncons r (fn (bs r)
                            (uncons r (fn (gl r)
                            (f cv pt ba st bs gl)))))))))))))))

(def state-cur-value (fn (s) (state-unmake s (fn (cv pt ba st bs gl) cv))))
(def state-set-cur-value (fn (s cv) (state-unmake s (fn (cv^ pt ba st bs gl)
                                    (state-make cv pt ba st bs gl)))))

(def state-get-global (fn (s key) (state-unmake s (fn (cv pt ba st bs gl) (getk gl key)))))
(def state-add-global (fn (s key val) (state-unmake s (fn (cv pt ba st bs gl)
                                      (state-make cv pt ba st bs (assoc gl key val))))))

(def state-get-local (fn (s key) (state-unmake s (fn (cv pt ba st bs gl) (getk st key)))))
(def state-add-local (fn (s key val) (state-unmake s (fn (cv pt ba st bs gl)
                                     (state-make cv pt ba (assoc st key val) bs gl)))))

(def state-borrow (fn (s sym)
 (def sb^ (fn (c rec)
  (if (nil? c)
   nil
   (state-unmake c (fn (cv pt ba st bs gl)
    (def ref (getk st sym))

    (if ref
     ref
     (rec ba rec)))))))

 (state-unmake s (fn (cv pt ba st bs gl)
  (if (in-list sym bs) ; already borrowed?
   s
   (if (or (sb^ ba sb^) (getk gl sym))
    (state-make cv pt ba st (reverse (cons sym (reverse bs))) gl)
    (print '[E] undefined var: ' (symbol-name sym) newline)))))))

(def state-borrow-list (fn (s) (state-unmake s (fn (cv pt ba st bs gl) bs))))

(def state-can-borrow (fn (s) (state-unmake s (fn (cv pt ba st bs gl) ba))))

(def state-branch-direct (fn (s) (state-unmake s (fn (cv pt ba st bs gl)
                                 (state-make cv s ba st bs gl)))))
(def state-branch-borrow (fn (s) (state-unmake s (fn (cv pt ba st bs gl)
                                 (state-make cv s s () () gl)))))

(def state-branch-is-borrow (fn (s) (state-unmake s (fn (cv pt ba st bs gl) (= pt ba)))))

(def state-merge (fn (s)
                  (state-unmake s  (fn ( cv  pt  ba  st  bs  gl)
                  (state-unmake pt (fn (pcv ppt pba pst pbs pgl)
                   (if (state-branch-is-borrow s)
                    (state-make pcv ppt pba pst pbs gl)
                    (state-make pcv ppt pba pst  bs gl)))))))) ; todo merge strat for accumulator?

(def i32-const (fn (i) (c-call LLVMConstInt * * i32-type int i int 1)))
(def i64-const (fn (i) (c-call LLVMConstInt * * i64-type int i int 1)))

(def nil-type-index (i64-const 0)) ; type 0 = nil
(def number-type-index (i64-const 1)) ; type 1 = number
(def string-type-index (i64-const 2)) ; type 2 = string
(def list-type-index (i64-const 3)) ; type 3 = list
(def function-type-index (i64-const 4)) ; type 4 = function
(def c-pointer-type-index (i64-const 5)) ; type 5 = c-pointer

(def type-index-friendly-name (fn (idx) (if (= nil-type-index idx) 'nil'
                                        (if (= number-type-index idx) 'number'
                                        (if (= string-type-index idx) 'string'
                                        (if (= list-type-index idx) 'list'
                                        (if (= function-type-index idx) 'function'
                                        (if (= c-pointer-type-index idx) 'c-pointer'
                                        'value'))))))))

(def extract-with-index (fn (val index label) (c-call LLVMBuildExtractValue * * main-b * val int index * label)))
(def extract-type-index (fn (val label) (extract-with-index val 0 label)))
(def extract-value      (fn (val label) (extract-with-index val 1 label)))
(def gep-with-index (fn (ptr index label)
                     (c-call LLVMBuildInBoundsGEP *
                      * main-b
                      * ptr
                      * (c-array (i64-const 0) (i32-const index))
                     int 2
                     * label)))
(def gep-list-elem-val (fn (list-elem label) (gep-with-index list-elem 0 label)))
(def gep-list-elem-next (fn (list-elem label) (gep-with-index list-elem 1 label)))

(def tr-nil (fn (state)
 (state-set-cur-value state
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
        nil-type-index
        (c-call LLVMConstNull * * i64-type))
    int 2))))

(def tr-number (fn (number state)
  (state-set-cur-value state
   (c-call LLVMConstNamedStruct *
     * value-type
     * (c-array
         number-type-index
         (c-call LLVMBuildBitCast * * main-b * (c-call LLVMConstReal * * double-type double number) * i64-type * 'pack-dbl'))
     int 2))))

(def tr-default (fn (state) (tr-number 1337 state))) ; todo raise error

(def tr-string (fn (string state)
 (def strval
   (c-call LLVMConstStringInContext * 
    * c
    * string
    int (+ (strlen string) 1)
    int 1)) ; do not zero terminate
 (def strmem
   (c-call LLVMAddGlobal *
    * m
    * (c-call LLVMTypeOf * * strval)
    * ''))
 (c-call LLVMSetGlobalConstant void * strmem int 1)
 (c-call LLVMSetInitializer void * strmem * strval)
 (state-set-cur-value state
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
        string-type-index
        (c-call LLVMBuildPtrToInt *
         * main-b
         * (c-call LLVMBuildInBoundsGEP *
            * main-b
            * strmem
            * (c-array (i64-const 0))
            int 1
            * 'str to ptr')
         * i64-type
         * 'ptr to int'))
    int 2))))

(def tr-empty-list
 (fn (state)
  (state-set-cur-value state
   (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
       list-type-index
       (c-call LLVMConstNull * * i64-type))
    int 2))))

(def tr-load-from-borrow
 (fn (sym state)
  (def s^ (state-borrow state sym))
  (if s^
   (do
    (def index (indexof sym (state-borrow-list s^)))
    (print '[I] ' (symbol-name sym) ' borrow index: ' index newline)
    (def val-loc (c-call LLVMBuildInBoundsGEP *
                  * main-b
                  * (state-get-local s^ '')
                  * (c-array (i64-const index))
                  int 1
                  * 'value-ptr'))
    (def val (c-call LLVMBuildLoad *
              * main-b
              * val-loc
              * 'value'))
    (state-set-cur-value (state-add-local s^ sym val) val))
   (print '[W] ' (symbol-name sym) ' not found!' newline))))

(def tr-load-from-global
 (fn (sym state)
  (def glb (state-get-global state sym))
    (if glb
     (unpair glb (fn (label val)
      (if (= 'var' label)
      (state-set-cur-value state (c-call LLVMBuildLoad * * main-b * val * 'load_from_var'))
       (print '[E] expected ' (symbol-name sym) ' to be a variable, actually is ' label newline))))
    (print '[E] unknown variable ' (symbol-name sym) newline))))

(def tr-load
 (fn (sym state)
  (def lcl (state-get-local state sym))
  (if lcl
   (state-set-cur-value state lcl)
   (if (state-can-borrow state)
    (tr-load-from-borrow sym state)
    (tr-load-from-global sym state)))))

; LLVMTypeKind
(def LLVMVoidTypeKind 0) ; type with no size
(def LLVMHalfTypeKind 1) ; 16 bit floating point type
(def LLVMFloatTypeKind 2) ; 32 bit floating point type
(def LLVMDoubleTypeKind 3) ; 64 bit floating point type
(def LLVMX86_FP80TypeKind 4) ; 80 bit floating point type (X87)
(def LLVMFP128TypeKind 5) ; 128 bit floating point type (112-bit mantissa)
(def LLVMPPC_FP128TypeKind 6) ; 128 bit floating point type (two 64-bits)
(def LLVMLabelTypeKind 7) ; Labels
(def LLVMIntegerTypeKind 8) ; Arbitrary bit width integers
(def LLVMFunctionTypeKind 9) ; Functions
(def LLVMStructTypeKind 10) ; Structures
(def LLVMArrayTypeKind 11) ; Arrays
(def LLVMPointerTypeKind 12) ; Pointers
(def LLVMVectorTypeKind 13) ; SIMD 'packed' format, or other vector type
(def LLVMMetadataTypeKind 14) ; Metadata
(def LLVMX86_MMXTypeKind 15) ; X86 MMX

(def tr-c-type
 (fn (type)
  (if (= (symbol 'void') type)
   void-type
  (if (= (symbol 'char') type)
   i8-type
  (if (= (symbol 'uchar') type)
   i8-type
  (if (= (symbol 'int') type)
   i32-type
  (if (= (symbol 'uint') type)
   i32-type
  (if (= (symbol 'float') type)
   float-type
  (if (= (symbol 'double') type)
   double-type
  (if (= (symbol '*') type)
   pointer-type
   double-type))))))))))

(def tr-cast-from-nil-to-c-type
 (fn (type val) (c-call LLVMConstNull * * (tr-c-type type))))

(def is-type-unsigned (fn (type) (= 'u' (substr (symbol-name type) 0 1))))

(def tr-cast-from-number-to-c-type
 (fn (type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str 'unpack-' (symbol-name type)))

  (def get-val (fn ()
                (c-call LLVMBuildBitCast *
                 * main-b
                 * (extract-value val 'extract-double')
                 * double-type
                 * 'convert-double')))

  (if (= kind LLVMIntegerTypeKind)
   (if (is-type-unsigned type)
    (c-call LLVMBuildFPToUI * * main-b * (get-val) * c-type * label)
    (c-call LLVMBuildFPToSI * * main-b * (get-val) * c-type * label))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (c-call LLVMBuildFPTrunc * * main-b * (get-val) * c-type * label)
  (if (= kind LLVMDoubleTypeKind)
   (get-val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (c-call LLVMBuildFPExt * * main-b * (get-val) * c-type * label)
   (c-call LLVMConstNull * * c-type)))))))

(def tr-cast-if-target-c-type-is-pointer
 (fn (type val)
  (if (= (symbol '*') type)
   (c-call LLVMBuildIntToPtr * * main-b * (extract-value val 'ptr-to-data') * pointer-type * 'cast-to-ptr')
   (c-call LLVMConstNull * * (tr-c-type type)))))

(def tr-cast-from-string-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-c-pointer-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-function-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-list-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-to-c-type ; todo write tests for all combinations!
 (fn (state type val)
  (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

  (def dyn-type (extract-type-index val 'dyn-type'))
  (def merge-block (c-call LLVMAppendBasicBlockInContext * * c * f * 'merge'))

  (def c-pointer-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'c-pointer-cast'))
  (def switch (c-call LLVMBuildSwitch * * main-b * dyn-type * c-pointer-cast-bb int 5))

  ; cast from nil
  (def nil-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'nil-cast'))
  (c-call LLVMAddCase void * switch * nil-type-index * nil-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * nil-cast-bb)
  (def nil-cast-v (tr-cast-from-nil-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from number
  (def number-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'number-cast'))
  (c-call LLVMAddCase void * switch * number-type-index * number-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * number-cast-bb)
  (def number-cast-v (tr-cast-from-number-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from string
  (def string-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'string-cast'))
  (c-call LLVMAddCase void * switch * string-type-index * string-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * string-cast-bb)
  (def string-cast-v (tr-cast-from-string-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from list
  (def list-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'list-cast'))
  (c-call LLVMAddCase void * switch * list-type-index * list-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * list-cast-bb)
  (def list-cast-v (tr-cast-from-list-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)
  
  ; cast from function
  (def function-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'function-cast'))
  (c-call LLVMAddCase void * switch * function-type-index * function-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * function-cast-bb)
  (def function-cast-v (tr-cast-from-function-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; default must be cast from c-pointer
  (c-call LLVMPositionBuilderAtEnd void * main-b * c-pointer-cast-bb)
  (def c-pointer-cast-v (tr-cast-from-c-pointer-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)
  
  (c-call LLVMPositionBuilderAtEnd void * main-b * merge-block)

  (def phi (c-call LLVMBuildPhi * * main-b * (tr-c-type type) * 'c-value'))

  (c-call LLVMAddIncoming void
   * phi
   * (c-array
      nil-cast-v
      number-cast-v
      string-cast-v
      list-cast-v
      function-cast-v
      c-pointer-cast-v)
   * (c-array
      nil-cast-bb
      number-cast-bb
      string-cast-bb
      list-cast-bb
      function-cast-bb
      c-pointer-cast-bb)
   int 6)

  (state-set-cur-value state phi)))

(def build-val
 (fn (type-id val)
  (c-call LLVMBuildInsertValue *
          * main-b
          * (c-call LLVMConstNamedStruct *
                    * value-type
                    * (c-array type-id (c-call LLVMGetUndef * * i64-type))
                    int 2)
          * (c-call LLVMBuildBitCast *
                    * main-b
                    * val
                    * i64-type
                    * 'convert-to-i64')
          int 1
          * (str 'packed-' (type-index-friendly-name type-id)))))

(def tr-cast-from-c-type
 (fn (state type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str 'cast-' (symbol-name type)))

  (if (= kind LLVMPointerTypeKind)
   (build-val c-pointer-type-index (c-call LLVMBuildPtrToInt * * main-b * val * i64-type * 'ptr-to-int'))
  (if (= kind LLVMIntegerTypeKind)
   (build-val number-type-index
    (if (is-type-unsigned type)
     (c-call LLVMBuildUIToFP * * main-b * val * double-type * label)
     (c-call LLVMBuildSIToFP * * main-b * val * double-type * label)))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (build-val number-type-index (c-call LLVMBuildFPExt * * main-b * val * double-type * label))
  (if (= kind LLVMDoubleTypeKind)
   (build-val number-type-index val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (build-val number-type-index (c-call LLVMBuildFPTrunc * * main-b * val * double-type * label))
   (c-call LLVMConstNull * * value-type)))))))) ; todo handle non numeric, non pointer types (are there any?)

(def tr-declare-c-fn
 (fn (name ret-type arg-types)
  (def ret-c-type (tr-c-type ret-type))

  (def c-typed-args (map (fn (type) (tr-c-type type)) arg-types))
  (def num-args (listlen c-typed-args))
  
  (def arg-t-array (apply c-array c-typed-args))
  (def fn-t (c-call LLVMFunctionType * * ret-c-type * arg-t-array int num-args int 0))

  (c-call LLVMAddFunction * * m * (symbol-name name) * fn-t)))

(def state-add-global-fn (fn (state fn-name ret-type arg-types)
 (state-add-global state fn-name (pair 'c-fn' (tr-declare-c-fn fn-name ret-type arg-types)))))

(def tr-c-call
 (fn (form state tr)
  (def fn-name (head (tail form)))

  (def ret-type (head (tail (tail form))))
  (def typed-args (chunk 2 (tail (tail (tail form))))) ; care for wrongly chunked!

  (def state^
   (if (state-get-global state fn-name)
    state
    (state-add-global-fn state fn-name ret-type (map fst (head typed-args)))))

  (def entry (state-get-global state^ fn-name))

  (def target-fn (unpair entry (fn (label val)
                                (if (= label 'c-fn')
                                 val
                                 (print '[E] not a C fn: ' (symbol-name fn-name) newline)))))

  (def casts (stap (fn (st typed-arg)
                    (unpair typed-arg
                     (fn (type arg)
                      (def st^ (tr (cons arg) st tr))
                      (pair st^ (tr-cast-to-c-type st^ type (state-cur-value st^))))))
                   state^
                   (reverse (head typed-args))))

  (def state^^ (fst casts))
  (def c-casted-args (reverse (snd casts)))

  (def num-args (listlen c-casted-args))

  (def is-void (= (symbol 'void') ret-type))
  (def res (c-call LLVMBuildCall *
            * main-b
            * target-fn
            * (apply c-array (map state-cur-value c-casted-args))
            int num-args
            * (if is-void '' (str 'call-' (symbol-name fn-name)))))

  (if is-void
   (tr-nil state^^)
   (state-set-cur-value state^^
    (tr-cast-from-c-type state^^ ret-type res)))))

; LLVMIntPredicate
(def LLVMIntEQ 32)  ; equal
(def LLVMIntNE 33)  ; not equal
(def LLVMIntUGT 34) ; unsigned greater than
(def LLVMIntUGE 35) ; unsigned greater or equal
(def LLVMIntULT 36) ; unsigned less than
(def LLVMIntULE 37) ; unsigned less or equal
(def LLVMIntSGT 38) ; signed greater than
(def LLVMIntSGE 39) ; signed greater or equal
(def LLVMIntSLT 40) ; signed less than
(def LLVMIntSLE 41) ; signed less or equal

(def tr-if
 (fn (form state tr)
  (if (not (= (listlen form) 4))
   (print '[E] expected: if <cond> <then> <else>' newline)

   (uncons (tail form) (fn (cond r)
   (uncons r (fn (then r)
   (uncons r (fn (else r)

   (def s^ (tr (cons cond) state tr))

   (def cond-v (state-cur-value s^))

   (def cond-true? (c-call LLVMBuildICmp * * main-b int LLVMIntNE * (extract-type-index cond-v 'if-cond-type') * nil-type-index * 'if-cond'))

   (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

   (def then-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-then'))
   (def else-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-else'))
   (def merge-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-merge'))

   (c-call LLVMBuildCondBr * * main-b * cond-true? * then-bb * else-bb)

   (c-call LLVMPositionBuilderAtEnd void * main-b * then-bb)
   (def s^then (tr (cons then) (state-branch-direct s^) tr))
   (def s^^ (state-merge s^then))
   (c-call LLVMBuildBr * * main-b * merge-bb)


   (c-call LLVMPositionBuilderAtEnd void * main-b * else-bb)
   (def s^else (tr (cons else) (state-branch-direct s^^) tr))
   (def s^^^ (state-merge s^else))
   (c-call LLVMBuildBr * * main-b * merge-bb)

   (c-call LLVMPositionBuilderAtEnd void * main-b * merge-bb)

   (def phi (c-call LLVMBuildPhi * * main-b * value-type * 'if-result'))

   (c-call LLVMAddIncoming void
    * phi
    * (c-array
       (state-cur-value s^then)
       (state-cur-value s^else))
   * (c-array
      then-bb
      else-bb)
   int 2)

   (state-set-cur-value s^^^ phi))))))))))

(def get-fn-type
 (fn (num-args)
   (def arg-t-array (apply c-array (cons value-ptr-type (map (fn (arg) value-type) (range num-args)))))

   (c-call LLVMFunctionType * * value-type * arg-t-array int (+ num-args 1) int 0)))

(def gen-fn
 (fn (num-args gen-body)
  (def fn-t (get-fn-type num-args))

  (def f (c-call LLVMAddFunction * * m * '' * fn-t))

  (def prev (c-call LLVMGetInsertBlock * * main-b))

  (def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
  (c-call LLVMPositionBuilderAtEnd void * main-b * bb)

  (def frame-reg (c-call LLVMGetParam * * f int 0))
  (def arg-regs (map (fn (i) (c-call LLVMGetParam * * f int (+ i 1))) (range num-args)))

  (def ret (gen-body frame-reg arg-regs))

  (c-call LLVMPositionBuilderAtEnd void * main-b * prev)

  (pair f ret)))

(def gen-fn-frame
 (fn (state f borrowed-vars)
   (print '[I] assembling closure frame: ' borrowed-vars newline)
   (def borrowed-vars-num (listlen borrowed-vars))
   (def frame-size (+ 8 (* 16 borrowed-vars-num)))
   (def frame-mem (c-call LLVMBuildCall *
                   * main-b
                   * (snd (state-get-global state (quote malloc)))
                   * (c-array (i32-const frame-size))
                   int 1
                   * 'alloc-frame'))
   ; todo memory management & free!!!
   (def frame (c-call LLVMBuildBitCast * * main-b * frame-mem * frame-ptr-type * 'cast-to-frame-ptr'))
   (c-call LLVMBuildStore *
    * main-b
    * (c-call LLVMBuildBitCast * * main-b * f * pointer-type * 'cast-f-to-f-tpr')
    * (c-call LLVMBuildInBoundsGEP * * main-b * frame * (c-array (i64-const 0) (i32-const 0)) int 2 * 'func-ptr-loc'))
   (def state^
    (leduce (fn (st borrowed)
             (unpair borrowed (fn (i b)
              (def st^ (tr-load b st))
              ; todo codegen store load into frame
              (def loc (c-call LLVMBuildInBoundsGEP *
                        * main-b
                        * frame
                        * (c-array (i64-const 0) (i32-const 1) (i64-const i))
                        int 3
                        * (str 'capture-' (symbol-name b) '-addr')))
              (c-call LLVMBuildStore * * main-b * (state-cur-value st^) * loc)
              st^)))
            state
            (zip (range borrowed-vars-num) borrowed-vars)))
   (print '[I] done' newline)

   (def func-pointer (c-call LLVMBuildPtrToInt * * main-b * frame * i64-type * 'pack-closure'))

   (state-set-cur-value state^ (build-val function-type-index func-pointer))))

(def tr-fn
 (fn (form state tr)
  ; todo check length ok

  (uncons (tail form) (fn (args body)
   (def num-args (listlen args))
   (def local-state (state-branch-borrow state))

   (unpair
    (gen-fn num-args
     (fn (frame-reg arg-regs)

      (def local-state^
       (leduce (fn (st arg)
                (unpair arg (fn (sym reg)
                 (state-add-local st sym reg))))
               (state-add-local local-state '' frame-reg)
               (zip args arg-regs)))

      (def local-state^^ (tr body local-state^ tr))

      (c-call LLVMBuildRet * * main-b * (state-cur-value local-state^^)) ; todo care for empty body

      local-state^^))
    (fn (f local-state^^)
     (def state^ (state-merge local-state^^))
     (gen-fn-frame state^ f (state-borrow-list local-state^^))))))))

(def tr-def-local
 (fn (name state)
  (state-add-local state name (state-cur-value state))))

(def tr-def-global
 (fn (name state)

  (def val (state-cur-value state))

  (def state^
     (if (state-get-global state name)
       state
       (do
         (def var (c-call LLVMAddGlobal * * m * value-type * (symbol-name name)))
         (c-call LLVMSetInitializer void * var *
          (if (= 0 (c-call LLVMIsConstant int * val))
           (c-call LLVMConstNull * * value-type)
           val))

         (state-add-global state name (pair 'var' var)))))

  (def gl-var (unpair (state-get-global state^ name)
               (fn (label var)
                (if (= 'var' label)
                 var
                 (print '[E] expected ' (symbol-name name) ' to be a variable, but actually is ' label newline)))))

  (c-call LLVMBuildStore * * main-b * val * gl-var)

  state^))

(def tr-def
 (fn (form state tr)
  (def name (head (tail form)))

  (def build (fn ()
   (def val (head (tail (tail form))))

   (if (nil? val)
    (tr-nil state)
    (tr (cons val) state tr))))

  (if (state-can-borrow state) ; is local var enough?
   (tr-def-local name (build))
   (tr-def-global name (build)))))

(def tr-call
 (fn (form state tr)
  ; todo check for length

  (uncons form (fn (f args)

  (def f-state (tr (cons f) state tr))

  (def args-state (stap (fn (st arg)
                        (def st^ (tr (cons arg) st tr))
                        (pair st^ st^)) ; todo do list in cur-val instead?
                   f-state
                   (reverse args)))

  (def state^ (fst args-state))
  (def arg-states (reverse (snd args-state)))

  (def num-args (listlen arg-states))

  (def f-type (get-fn-type num-args))
  (def f-ptr-type (c-call LLVMPointerType * * f-type int 0))

  (def frame-ptr (c-call LLVMBuildIntToPtr *
                  * main-b
                  * (extract-value (state-cur-value f-state) 'fn-frame-addr')
                  * frame-ptr-type
                  * 'fn-frame-addr-to-ptr'))

  (def target-fn-loc (c-call LLVMBuildInBoundsGEP *
                      * main-b
                      * frame-ptr
                      * (c-array (i64-const 0) (i32-const 0))
                      int 2
                      * 'fn-addr'))

  (def borrowed-vals-loc (c-call LLVMBuildInBoundsGEP *
                          * main-b
                          * frame-ptr
                          * (c-array (i64-const 0) (i32-const 1) (i64-const 0))
                          int 3
                          * 'borrowed-vals-addr'))

  (def target-fn (c-call LLVMBuildBitCast *
                  * main-b
                  * (c-call LLVMBuildLoad * * main-b * target-fn-loc * 'fn-ptr-void-ptr-type')
                  * f-ptr-type
                  * 'fn-ptr'))

  ; todo call with frame
  (def res (c-call LLVMBuildCall *
            * main-b
            * target-fn
            * (apply c-array (cons borrowed-vals-loc (map state-cur-value arg-states)))
            int (+ num-args 1)
            * 'call-fn'))

  (state-set-cur-value state^ res)))))

(def tr-form
 (fn (form state tr)
   (if (empty? form)
     (tr-empty-list state)

   (if (= (symbol 'def') (head form))
     (tr-def form state tr)

   (if (= (symbol 'c-call') (head form))
     (tr-c-call form state tr)

   (if (= (symbol 'if') (head form))
     (tr-if form state tr)

   (if (= (symbol 'fn') (head form))
     (tr-fn form state tr)

   (tr-call form state tr))))))))

(def tr
  (fn (code)
    (def s-malloc (state-add-global-fn (init-state) (quote malloc) (quote *) (cons (quote uint))))

    (def cons-fn (fst
     (gen-fn 2 (fn (frame args) (unpair args (fn (e l)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))

      (def is-list (c-call LLVMBuildICmp * * main-b int LLVMIntEQ * (extract-type-index l 'l-type') * list-type-index * 'is-list'))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def alloc (c-call LLVMBuildCall *
                  * main-b
                  * (snd (state-get-global s-malloc (quote malloc)))
                  * (c-array (i32-const 24))
                  int 1
                  * 'list-elem-mem-void-ptr'))

      (def list-elem-mem (c-call LLVMBuildBitCast *
                          * main-b
                          * alloc
                          * list-elem-ptr-type
                          * 'list-elem-mem'))

      (c-call LLVMBuildStore *
       * main-b
       * e
       * (gep-list-elem-val list-elem-mem 'list-elem-val-ptr'))
      (c-call LLVMBuildStore *
       * main-b
       * (c-call LLVMBuildIntToPtr * * main-b * (extract-value l 'l-val') * pointer-type * 'cast-to-ptr')
       * (gep-list-elem-next list-elem-mem 'list-elem-next-ptr'))

      (def new-l (build-val list-type-index (c-call LLVMBuildPtrToInt * * main-b * list-elem-mem * i64-type * 'cast-to-int')))

      (c-call LLVMBuildRet * * main-b * new-l)

      nil))))))

    (def s-cons (state-add-local s-malloc (quote cons)
     (state-cur-value (gen-fn-frame s-malloc cons-fn ()))))

    (def head-fn (fst
     (gen-fn 1 (fn (frame args) (uncons args (fn (l _)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))
      (def not-empty-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'not-empty'))

      (def is-list (c-call LLVMBuildICmp * * main-b int LLVMIntEQ * (extract-type-index l 'l-type') * list-type-index * 'is-list'))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def head-ptr (c-call LLVMBuildIntToPtr * * main-b * (extract-value l 'l-val') * list-elem-ptr-type * 'head-ptr'))

      (def is-empty (c-call LLVMBuildIsNull * * main-b * head-ptr * 'is-empty'))

      (c-call LLVMBuildCondBr * * main-b * is-empty * nil-bb * not-empty-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * not-empty-bb)

      (def head-val (c-call LLVMBuildLoad *
                     * main-b
                     * (gep-list-elem-val head-ptr 'head-val-ptr')
                     * 'head-val'))

      (c-call LLVMBuildRet * * main-b * head-val)

      nil))))))

    (def s-head (state-add-local s-cons (quote head)
     (state-cur-value (gen-fn-frame s-cons head-fn ()))))

    (def tail-fn (fst
     (gen-fn 1 (fn (frame args) (uncons args (fn (l _)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))
      (def not-empty-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'not-empty'))

      (def is-list (c-call LLVMBuildICmp * * main-b int LLVMIntEQ * (extract-type-index l 'l-type') * list-type-index * 'is-list'))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def head-ptr (c-call LLVMBuildIntToPtr * * main-b * (extract-value l 'l-val') * list-elem-ptr-type * 'head-ptr'))

      (def is-empty (c-call LLVMBuildIsNull * * main-b * head-ptr * 'is-empty'))

      (c-call LLVMBuildCondBr * * main-b * is-empty * nil-bb * not-empty-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * not-empty-bb)

      (def head-next (c-call LLVMBuildLoad *
                      * main-b
                      * (gep-list-elem-next head-ptr 'head-next-ptr')
                      * 'head-next'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val list-type-index (c-call LLVMBuildPtrToInt * * main-b * head-next * i64-type * 'cast-to-int')))

      nil))))))

    (def s-tail (state-add-local s-head (quote tail)
     (state-cur-value (gen-fn-frame s-head tail-fn ()))))

    (def s s-tail)

    (def tr^ (fn (c state rec)
      (if (empty? c)
       state
       ((fn (h t)
         (def state
            (if (is-list h)
             (tr-form h state rec)
            (if (is-string h)
             (tr-string h state)
            (if (is-number h)
             (tr-number h state)
            (if (is-symbol h)
             (tr-load h state)
             (tr-default state)))))) ; todo other options
         (rec t state rec)
       ) (head c) (tail c)))))

    (tr^ code s tr^)))

(tr code)

(c-call LLVMBuildRetVoid * * main-b)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err) newline))

(c-call LLVMDisposeBuilder void * main-b)

(print newline)

(c-call LLVMDumpModule void * m)
(if (= 0 (c-call LLVMPrintModuleToFile int * m * 'out.ll' * (c-ref err)))
    nil
    (print (c-str err) newline))
