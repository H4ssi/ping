
(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'test' * c))
(def i (c-call LLVMInt32TypeInContext * * c))
(def ps (c-array i i))
(def ft (c-call LLVMFunctionType * * i * ps int 2 int 0))
(def f (c-call LLVMAddFunction * * m * 'plus' * ft))
(def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
(def b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * b * bb)
(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))
(c-call LLVMBuildRet void * b * r)
(c-call LLVMDisposeBuilder void * b)

(c-call LLVMDumpModule void * m)

(def ee (c-ref))
(def err (c-ref))

(if (= 0 (c-call LLVMCreateJITCompilerForModule int * (c-ref ee) * m int 0 * (c-ref err)))
    (def noop nil)
    (print (c-str err)))

(print '
')

(def to-list
  (fn (string)

    (def to-list^
      (fn (pos rec)
        ((fn (c) (if (= c '') () (cons c (rec (+ pos 1) rec))))
         (substr string pos 1))))

    (to-list^ 0 to-list^)))

(def OP '(') ; ) (
(def CP ')')

(def newline '
')
(def whitespace (str ' 	' newline))
(def digit '0123456789')

(def nil (cons))
(def nil? (fn (w) (if w nil '')))
(def not  (fn (c) (if c nil '')))

(def empty? (fn (l) (nil? (tail l))))

(def reduce
  (fn (f i l)
    (def reduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (f (rec res (tail ll) rec) (head ll)))))

    (reduce^ i l reduce^)))

(def leduce
  (fn (f i l)
    (def leduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (rec (f res (head ll)) (tail ll) rec))))

    (leduce^ i l leduce^)))

(def reverse
  (fn (l)
    (leduce (fn (res i) (cons i res)) () l)))

(def filter
  (fn (p l)
    (reduce 
      (fn (res i)
        (if (p i) (cons i res) res))
      ()
      l)))

(def map
  (fn (t l)
    (reduce
      (fn (res i)
        (cons (t i) res))
      ()
      l)))

(def in-list
  (fn (e l)
    (not (empty? (filter (fn (i) (= i e)) l)))))   

(def in-str
  (fn (c string) (in-list c (to-list string))))

(def is-whitespace
  (fn (x) (in-str x whitespace)))
(def is-newline
  (fn (x) (in-str x newline)))
(def not-is-newline
  (fn (x) (not (is-newline x))))
(def is-digit
  (fn (x) (in-str x digit)))

(def t-ws
  (fn (x) (if (is-whitespace x) '_' x)))

(def drop-while 
  (fn (p l)
    
    (def drop-while^
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (rec (tail ll) rec)
            ll))))

    (drop-while^ l drop-while^)))

(def take-while
  (fn (p l)
    
    (def take-while^ 
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (cons (head ll) (rec (tail ll) rec))
            ()))))

    (take-while^ l take-while^)))

(def pair
  (fn (l r)
    (cons l (cons r))))


(def parse-sym 
  (fn (cs prs)
    (def sym-char
      (fn (c) (not (in-str c (str whitespace CP OP '\';')))))

    (pair 
      (symbol (str (take-while sym-char cs)))
      (drop-while sym-char cs))))

(def digit-to-number
  (fn (d)
    (if (= d '0') 0
    (if (= d '1') 1
    (if (= d '2') 2
    (if (= d '3') 3
    (if (= d '4') 4
    (if (= d '5') 5
    (if (= d '6') 6
    (if (= d '7') 7
    (if (= d '8') 8
    (if (= d '9') 9
    nil))))))))))))

(def parse-number
  (fn (cs prs)
    (def dec (take-while is-digit cs))
    (def r   (drop-while is-digit cs))
    
    (def rr  (if (empty? r) 
               r 
               (if (= '.' (head r)) 
                (tail r)
                r)))

    (def com (take-while is-digit rr))
    (def rrr (drop-while is-digit rr))

    (def n   (fn (l) (leduce (fn (nn dd) (+ (digit-to-number dd) (* 10 nn))) 0 l)))
    (def m   (fn (l) (leduce (fn (nn dd) (* 10 nn)) 1 l)))

    (pair (+ (n dec) (* (n com) (/ (m com)))) rrr)))
    
(def err (fn (x m) (print m newline) (pair (cons nil) x)))

(def parse-list 
  (fn (cs prs)
    (def parse-list^
      (fn (ccs rec)
        
        ((fn (p)
          (if (nil? p)
            (err ccs 'unexpected eof during list')
            ((fn (t r)
              (if (nil? t) ; end of list maybe?
                (if (empty? r)
                  (err ccs 'missing end of list')
                  (if (= CP (head r))
                    (pair () (tail r))
                    (err ccs (str 'unexpected: ' (head r)))))
                ((fn (pp)
                ((fn (tt rr)
                  (pair (cons t tt) rr)
                )(head pp)(head (tail pp)))
                )(rec r rec)))
            )(head p)(head (tail p))))
        )(prs ccs prs))))

      (parse-list^ (tail cs) parse-list^)))

(def parse-string
  (fn (cs rec)
    (def pcons
      (fn (i p)
        (def f (head p))
        (def s (head (tail p)))

        (if f 
          (pair (cons i f) s)
          p)))

    (def escape 
      (fn (escape-next ccs rec)
        (if (empty? ccs)
          (err ccs 'unexpected eof during string')
          (if escape-next
            (pcons (head ccs) (rec nil (tail ccs) rec))
            (if (= '\\' (head ccs))
              (rec '' (tail ccs) rec)
              (if (= '\'' (head ccs))
                (pair () (tail ccs))
                (pcons (head ccs) (rec nil (tail ccs) rec))))))))

    (def e (escape nil (tail cs) escape))
    
    (def f (head e))
    (def s (head (tail e)))

    (pair (str f) s)))

(def parse-expr
  (fn (cs rec)
    (if (empty? cs)
      nil
      ((fn (c)
        (if (is-whitespace c) (rec (drop-while is-whitespace cs) rec)
        (if (= c ';') (rec (drop-while not-is-newline cs) rec)
        (if (= c OP) (parse-list cs rec)
        (if (= c CP) (pair nil cs)
        (if (= c '\'') (parse-string cs rec)
        (if (is-digit c) (parse-number cs rec)
        (parse-sym cs rec)
        ))))))
      )(head cs)))))


(def parse-all
  (fn (cs rec)
    ((fn (p)
    (if (nil? p)
      ()
      ((fn (t r)
        (if (nil? t)
          (cons t)
          (cons t (rec r rec)))
      )(head p)(head (tail p)))
    )
    )(parse-expr cs parse-expr))))


(print (parse-all (to-list INPUT) parse-all))
