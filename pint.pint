; Copyright (C) 2015  Florian Hassanen
;
; This file is part of pint.
;
; pint is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; pint is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'test' * c))
(def i (c-call LLVMInt32TypeInContext * * c))
(def ps (c-array i i))
(def ft (c-call LLVMFunctionType * * i * ps int 2 int 0))
(def f (c-call LLVMAddFunction * * m * 'plus' * ft))
(def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
(def b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * b * bb)
(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))
(c-call LLVMBuildRet void * b * r)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(if (= 0 (c-call LLVMVerifyFunction int * f int LLVMPrintMessageAction))
    nil
    (print 'error verifying function'))

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err)))

(c-call LLVMDisposeBuilder void * b)

(c-call LLVMDumpModule void * m)

(c-call LLVMLinkInMCJIT void)
(c-call ExternLLVMInitializeNativeTarget void) ; todo inlining does not work :(
(c-call ExternLLVMInitializeNativeAsmPrinter void) 

(def ee (c-ref))

(if (= 0 (c-call LLVMCreateJITCompilerForModule int * (c-ref ee) * m int 0 * (c-ref err)))
    nil
    (print (c-str err)))

(def plus (c-call LLVMGetPointerToGlobal * * ee * f))

(print 'calling ' plus)

(print '3 + 4 = ' (c-call * plus int int 3 int 4))

(print '
')

(def to-list
  (fn (string)

    (def to-list^
      (fn (pos rec)
        ((fn (c) (if (= c '') () (cons c (rec (+ pos 1) rec))))
         (substr string pos 1))))

    (to-list^ 0 to-list^)))

(def OP '(') ; ) (
(def CP ')')

(def newline '
')
(def whitespace (str ' 	' newline))
(def digit '0123456789')

(def nil? (fn (w) (if w nil '')))
(def not  (fn (c) (if c nil '')))

(def and (fn (a b) (if a b a)))
(def or (fn (a b) (if a a b)))

(def empty? (fn (l) (nil? (tail l))))

(def reduce
  (fn (f i l)
    (def reduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (f (rec res (tail ll) rec) (head ll)))))

    (reduce^ i l reduce^)))

(def leduce
  (fn (f i l)
    (def leduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (rec (f res (head ll)) (tail ll) rec))))

    (leduce^ i l leduce^)))

(def listlen
  (fn (l)
    (leduce (fn (res i) (+ 1 res)) 0 l)))

(def strlen
  (fn (s) (listlen (to-list s))))

(def reverse
  (fn (l)
    (leduce (fn (res i) (cons i res)) () l)))

(def filter
  (fn (p l)
    (reduce 
      (fn (res i)
        (if (p i) (cons i res) res))
      ()
      l)))

(def map
  (fn (t l)
    (reduce
      (fn (res i)
        (cons (t i) res))
      ()
      l)))

(def in-list
  (fn (e l)
    (not (empty? (filter (fn (i) (= i e)) l)))))   

(def in-str
  (fn (c string) (in-list c (to-list string))))

(def is-whitespace
  (fn (x) (in-str x whitespace)))
(def is-newline
  (fn (x) (in-str x newline)))
(def not-is-newline
  (fn (x) (not (is-newline x))))
(def is-digit
  (fn (x) (in-str x digit)))

(def t-ws
  (fn (x) (if (is-whitespace x) '_' x)))

(def drop-while 
  (fn (p l)
    
    (def drop-while^
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (rec (tail ll) rec)
            ll))))

    (drop-while^ l drop-while^)))

(def take-while
  (fn (p l)
    
    (def take-while^ 
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (cons (head ll) (rec (tail ll) rec))
            ()))))

    (take-while^ l take-while^)))

(def assoc 
 (fn (m k v)
  (cons k (cons v m))))

(def getk
 (fn (m k)
   (def getk^
     (fn (mm rec)
       (if (empty? mm)
         nil
         (if (= k (head mm))
            (head (tail mm))
            (rec (tail (tail mm)) rec)))))

   (getk^ m getk^)))

(print (getk () 'test') newline) ; should be nil
(def testmap (assoc (assoc (assoc () 'a' 1) 'b' 2) 'a' 3))
(print (getk testmap 'a') newline) ; should be 3
(print (getk testmap 'b') newline) ; should be 2

(def pair
  (fn (l r)
    (cons l (cons r))))

(def unpair
 (fn (p f)
  (f (head p) (head (tail p)))))

(def split
 (fn (count list)
  
  (def split^
   (fn (list i rec)
    (if (= i count)
     (pair () list)
     (if (empty? list)
      (pair () nil)
      (unpair (rec (tail list) (+ i 1) rec)
       (fn (h t)
        (pair (cons (head list) h) t)))))))
  
  (split^ list 0 split^)))

(def take
 (fn (count list)
  (unpair (split count list)
   (fn (h t) h))))

(def drop
 (fn (count list)
  (unpair (split count list)
   (fn (h t) t))))

(def chunk
 (fn (chunk-size list)
  (def chunk^
   (fn (list rec)
    (unpair (split 2 list)
     (fn (h t)
      (if (nil? t)
       (pair () h)
       (if (empty? t)
        (pair (cons h) nil)
        (unpair (rec t rec)
         (fn (hh tt)
          (pair (cons h hh) tt)))))))))
  (chunk^ list chunk^)))

(def parse-sym 
  (fn (cs prs)
    (def sym-char
      (fn (c) (not (in-str c (str whitespace CP OP '\';')))))

    (pair 
      (symbol (str (take-while sym-char cs)))
      (drop-while sym-char cs))))

(def digit-to-number
  (fn (d)
    (if (= d '0') 0
    (if (= d '1') 1
    (if (= d '2') 2
    (if (= d '3') 3
    (if (= d '4') 4
    (if (= d '5') 5
    (if (= d '6') 6
    (if (= d '7') 7
    (if (= d '8') 8
    (if (= d '9') 9
    nil))))))))))))

(def parse-number
  (fn (cs prs)
    (def dec (take-while is-digit cs))
    (def r   (drop-while is-digit cs))
    
    (def rr  (if (empty? r) 
               r 
               (if (= '.' (head r)) 
                (tail r)
                r)))

    (def com (take-while is-digit rr))
    (def rrr (drop-while is-digit rr))

    (def n   (fn (l) (leduce (fn (nn dd) (+ (digit-to-number dd) (* 10 nn))) 0 l)))
    (def m   (fn (l) (leduce (fn (nn dd) (* 10 nn)) 1 l)))

    (pair (+ (n dec) (* (n com) (/ (m com)))) rrr)))
    
(def err (fn (x m) (print m newline) (pair (cons nil) x)))

(def parse-list 
  (fn (cs prs)
    (def parse-list^
      (fn (ccs rec)
        
        ((fn (p)
          (if (nil? p)
            (err ccs 'unexpected eof during list')
            ((fn (t r)
              (if (nil? t) ; end of list maybe?
                (if (empty? r)
                  (err ccs 'missing end of list')
                  (if (= CP (head r))
                    (pair () (tail r))
                    (err ccs (str 'unexpected: ' (head r)))))
                ((fn (pp)
                ((fn (tt rr)
                  (pair (cons t tt) rr)
                )(head pp)(head (tail pp)))
                )(rec r rec)))
            )(head p)(head (tail p))))
        )(prs ccs prs))))

      (parse-list^ (tail cs) parse-list^)))

(def parse-string
  (fn (cs rec)
    (def pcons
      (fn (i p)
        (def f (head p))
        (def s (head (tail p)))

        (if f 
          (pair (cons i f) s)
          p)))

    (def escape 
      (fn (escape-next ccs rec)
        (if (empty? ccs)
          (err ccs 'unexpected eof during string')
          (if escape-next
            (pcons (head ccs) (rec nil (tail ccs) rec))
            (if (= '\\' (head ccs))
              (rec '' (tail ccs) rec)
              (if (= '\'' (head ccs))
                (pair () (tail ccs))
                (pcons (head ccs) (rec nil (tail ccs) rec))))))))

    (def e (escape nil (tail cs) escape))
    
    (def f (head e))
    (def s (head (tail e)))

    (pair (str f) s)))

(def parse-expr
  (fn (cs rec)
    (if (empty? cs)
      nil
      ((fn (c)
        (if (is-whitespace c) (rec (drop-while is-whitespace cs) rec)
        (if (= c ';') (rec (drop-while not-is-newline cs) rec)
        (if (= c OP) (parse-list cs rec)
        (if (= c CP) (pair nil cs)
        (if (= c '\'') (parse-string cs rec)
        (if (is-digit c) (parse-number cs rec)
        (parse-sym cs rec)
        ))))))
      )(head cs)))))


(def parse-all
  (fn (cs rec)
    ((fn (p)
    (if (nil? p)
      ()
      ((fn (t r)
        (if (nil? t)
          (cons t)
          (cons t (rec r rec)))
      )(head p)(head (tail p)))
    )
    )(parse-expr cs parse-expr))))

(def code (parse-all (to-list INPUT) parse-all))

(print code)

(def is-number (fn (o) (= o (+ o))))
(def is-string (fn (o) (= o (str o))))
(def is-symbol (fn (o) (= o (symbol (symbol-name o)))))
(def is-list (fn (o) (if (= o ()) o (tail o))))
(def is-fn (fn (o) (if o (not (= o o)) o)))

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'real' * c))
(def int-type (c-call LLVMInt64TypeInContext * * c))
(def double-type (c-call LLVMDoubleTypeInContext * * c))
(def value-type (c-call LLVMStructCreateNamed * * c * 'value_type'))
(c-call LLVMStructSetBody void * value-type * (c-array int-type int-type) int 2 int 0)
(def ptr-type (c-call LLVMInt32TypeInContext * * c))
(def void-type (c-call LLVMVoidTypeInContext * * c))

(def main-f-type (c-call LLVMFunctionType * * void-type * (c-array) int 0 int 0))
(def main-f (c-call LLVMAddFunction * * m * 'main' * main-f-type))
(def main-bb (c-call LLVMAppendBasicBlockInContext * * c * main-f * 'entry'))
(def main-b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * main-b * main-bb)
;(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))

(def state-mk (fn (cur-val global-names) (cons cur-val (cons global-names))))
(def state-cur-val (fn (s) (head s)))
(def state-global-names (fn (s) (head (tail s))))
(def init-state (fn () (state-mk nil ())))

(def nil-type-index (c-call LLVMConstInt * * int-type int 0 int 1)) ; type 0 = nil
(def number-type-index (c-call LLVMConstInt * * int-type int 1 int 1)) ; type 1 = number
(def string-type-index (c-call LLVMConstInt * * int-type int 2 int 1)) ; type 2 = string

(def tr-nil (fn (state)
 (state-mk
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
        nil-type-index
        (c-call LLVMConstNull * * int-type))
    int 2)
  (state-global-names state))))

(def tr-number (fn (number state)
  (state-mk
   (c-call LLVMConstNamedStruct *
     * value-type
     * (c-array
         nil-type-index
         (c-call LLVMBuildBitCast * * main-b * (c-call LLVMConstReal * * double-type double number) * int-type * 'pack-dbl'))
     int 2)
   (state-global-names state))))

(def tr-default (fn (state) (tr-number 1337 state)))

(def tr-string (fn (string state)
 (def strval
   (c-call LLVMConstStringInContext * 
    * c
    * string
    int (+ (strlen string) 1)
    int 1)) ; do not zero terminate
 (def strmem
   (c-call LLVMAddGlobal *
    * m
    * (c-call LLVMTypeOf * * strval)
    * ''))
 (c-call LLVMSetGlobalConstant void * strmem int 1)
 (c-call LLVMSetInitializer void * strmem * strval)
 (state-mk
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
        string-type-index
        (c-call LLVMBuildPtrToInt *
         * main-b
         * (c-call LLVMBuildInBoundsGEP *
            * main-b
            * strmem
            * (c-array (c-call LLVMConstInt * * int-type int 0 int 1))
            int 1
            * 'str to ptr')
         * int-type
         * 'ptr to int'))
    int 2)
  (state-global-names state))))

(def tr-load
 (fn (sym state)
  (def glb-nms (state-global-names state))

  (def glb-var (getk glb-nms sym))

  (if glb-var
   (state-mk (c-call LLVMBuildLoad * * main-b * glb-var * 'load_from_global') glb-nms)
   (do
    (print '[E] unkown variable ' (symbol-name sym) newline)
    (tr-nil state)))))

; LLVMTypeKind
(def LLVMVoidTypeKind 0) ; type with no size
(def LLVMHalfTypeKind 1) ; 16 bit floating point type
(def LLVMFloatTypeKind 2) ; 32 bit floating point type
(def LLVMDoubleTypeKind 3) ; 64 bit floating point type
(def LLVMX86_FP80TypeKind 4) ; 80 bit floating point type (X87)
(def LLVMFP128TypeKind 5) ; 128 bit floating point type (112-bit mantissa)
(def LLVMPPC_FP128TypeKind 6) ; 128 bit floating point type (two 64-bits)
(def LLVMLabelTypeKind 7) ; Labels
(def LLVMIntegerTypeKind 8) ; Arbitrary bit width integers
(def LLVMFunctionTypeKind 9) ; Functions
(def LLVMStructTypeKind 10) ; Structures
(def LLVMArrayTypeKind 11) ; Arrays
(def LLVMPointerTypeKind 12) ; Pointers
(def LLVMVectorTypeKind 13) ; SIMD 'packed' format, or other vector type
(def LLVMMetadataTypeKind 14) ; Metadata
(def LLVMX86_MMXTypeKind 15) ; X86 MMX

(def void-type (c-call LLVMVoidTypeInContext * * c))
(def i8-type (c-call LLVMInt8TypeInContext * * c))
(def i32-type (c-call LLVMInt32TypeInContext * * c))
(def i64-type (c-call LLVMInt64TypeInContext * * c))
(def float-type (c-call LLVMFloatTypeInContext * * c))
(def pointer-type (c-call LLVMPointerType * * i8-type int 0))

(def tr-c-type
 (fn (type)
  (if (= (symbol 'void') type)
   void-type
  (if (= (symbol 'char') type)
   i8-type
  (if (= (symbol 'uchar') type)
   i8-type
  (if (= (symbol 'int') type)
   i32-type
  (if (= (symbol 'uint') type)
   i32-type
  (if (= (symbol 'float') type)
   float-type
  (if (= (symbol 'double') type)
   double-type
  (if (= (symbol '*') type)
   pointer-type
   double-type))))))))))

(def tr-cast-from-nil-to-c-type
 (fn (type val) (c-call LLVMConstNull * * (tr-c-type type))))

(def is-type-unsigned (fn (type) (= 'u' (substr (symbol-name type) 0 1))))

(def tr-cast-from-number-to-c-type
 (fn (type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str 'unpack-' (symbol-name type)))

  (def get-val (fn ()
                (c-call LLVMBuildBitCast *
                 * main-b
                 * (c-call LLVMBuildExtractValue * * main-b * val int 1 * 'extract-double')
                 * double-type
                 * 'convert-double')))

  (if (= kind LLVMIntegerTypeKind)
   (if (is-type-unsigned type)
    (c-call LLVMBuildFPToUI * * main-b * (get-val) * c-type * label)
    (c-call LLVMBuildFPToSI * * main-b * (get-val) * c-type * label))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (c-call LLVMBuildFPTrunc * * main-b * (get-val) * c-type * label)
  (if (= kind LLVMDoubleTypeKind)
   (get-val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (c-call LLVMBuildFPExt * * main-b * (get-val) * c-type * label)
   (c-call LLVMConstNull * * c-type)))))))

(def tr-cast-from-string-to-c-type
 (fn (type val)
  (if (= (symbol '*') type)
   (c-call LLVMBuildIntToPtr * * main-b * (c-call LLVMBuildExtractValue * * main-b * val int 1 * 'ptr-to-str-data') * pointer-type * 'pack-ptr')
   (c-call LLVMConstNull * * (tr-c-type type)))))

(def tr-cast-to-c-type ; todo write tests for all combinations!
 (fn (state type val)
  (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

  (def dyn-type (c-call LLVMBuildExtractValue * * main-b * val int 0 * 'dyn-type'))
  (def merge-block (c-call LLVMAppendBasicBlockInContext * * c * f * 'merge'))

  (def string-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'string-cast'))
  (def switch (c-call LLVMBuildSwitch * * main-b * dyn-type * string-cast-bb int 2))

  ; cast from nil
  (def nil-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'nil-cast'))
  (c-call LLVMAddCase void * switch * nil-type-index * nil-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * nil-cast-bb)
  (def nil-cast-v (tr-cast-from-nil-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from number
  (def number-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'number-cast'))
  (c-call LLVMAddCase void * switch * number-type-index * number-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * number-cast-bb)
  (def number-cast-v (tr-cast-from-number-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; default must be cast from string
  (c-call LLVMPositionBuilderAtEnd void * main-b * string-cast-bb)
  (def string-cast-v (tr-cast-from-string-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  (c-call LLVMPositionBuilderAtEnd void * main-b * merge-block)

  (def phi (c-call LLVMBuildPhi * * main-b * (tr-c-type type) * 'c-value'))

  (c-call LLVMAddIncoming void
   * phi
   * (c-array
      nil-cast-v
      number-cast-v
      string-cast-v)
   * (c-array
      nil-cast-bb
      number-cast-bb
      string-cast-bb)
   int 3)

  (state-mk phi (state-global-names state))))

(def tr-cast-from-c-type
 (fn (state type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str 'cast-' (symbol-name type)))
  (def pack-label (str 'pack-' (symbol-name type)))

  (def build-val
   (fn (type-id val)
    (c-call LLVMBuildInsertValue *
            * main-b
            * (c-call LLVMConstNamedStruct *
                      * value-type
                      * (c-array type-id (c-call LLVMGetUndef * * i64-type))
                      int 2)
            * (c-call LLVMBuildBitCast *
                      * main-b
                      * val
                      * i64-type
                      * 'convert-to-i64')
            int 1
            * pack-label)))

  (if (= kind LLVMIntegerTypeKind)
   (build-val number-type-index
    (if (is-type-unsigned type)
     (c-call LLVMBuildUIToFP * * main-b * val * double-type * label)
     (c-call LLVMBuildSIToFP * * main-b * val * double-type * label)))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (build-val number-type-index (c-call LLVMBuildFPExt * * main-b * val * double-type * label))
  (if (= kind LLVMDoubleTypeKind)
   (build-val number-type-index val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (build-val number-type-index (c-call LLVMBuildFPTrunc * * main-b * val * double-type * label))
   (c-call LLVMConstNull * * value-type))))))) ; todo handle non numeric types

(def tr-c-call
 (fn (form state tr)
  (def fn-name (head (tail form)))
  (def ret-type (head (tail (tail form))))
  (def typed-args (chunk 2 (tail (tail (tail form)))))

  (def ret-c-type (tr-c-type ret-type))
  (def c-typed-args (map (fn (arg) (unpair arg (fn (type name) (tr-c-type type)))) (head typed-args))) ; care for wrongly chunked!
  
  (def arg-t-array (c-array (head c-typed-args))) ; todo all args!!
  (def fn-t (c-call LLVMFunctionType * * ret-c-type * arg-t-array int 1 int 0))

  (def target-fn (c-call LLVMAddFunction * * m * (symbol-name fn-name) * fn-t))

  (def arg-cast (unpair (head (head typed-args)) (fn (type arg) (tr-cast-to-c-type state type (state-cur-val (tr (cons arg) state tr))))))
  
  (def res (c-call LLVMBuildCall *
            * main-b
            * target-fn
            * (c-array (state-cur-val arg-cast))
            int 1
            * (str 'call-' (symbol-name fn-name))))
  
  (def packed-res (tr-cast-from-c-type state ret-type res))

  (state-mk packed-res (state-global-names state))))

(def tr-form
 (fn (form state tr)
   (def glb-nms (state-global-names state))

   (if (= (symbol 'def') (head form))
     (do
       (def name (head (tail form)))
       (def glb-nms^ 
          (if (getk glb-nms name)
            glb-nms
            (do
              (def var (c-call LLVMAddGlobal * * m * value-type * (symbol-name (head (tail form)))))
              (c-call LLVMSetInitializer void * var * (c-call LLVMConstNull * * value-type))
              (assoc glb-nms name var))))

       (def gl-var (getk glb-nms^ name))
       
       (def val (head (tail (tail form))))

       (def state^ (state-mk nil glb-nms^))
       (def state^ 
         (if (nil? val)
            (tr-nil state^)
            (tr (cons val) state^ tr)))

       (c-call LLVMBuildStore * * main-b * (state-cur-val state^) * gl-var)

       state^)
   (if (= (symbol 'c-call') (head form))
     (tr-c-call form state tr)
   (tr-default state)))))

(def tr
  (fn (c)

    (def tr^ (fn (c state rec)
      (if (empty? c)
       state
       ((fn (h t)
         (def state
            (if (is-list h)
             (tr-form h state rec)
            (if (is-string h)
             (tr-string h state)
            (if (is-number h)
             (tr-number h state)
            (if (is-symbol h)
             (tr-load h state)
             (tr-default state)))))) ; todo other options
         (rec t state rec)
       ) (head c) (tail c)))))

    (tr^ c (init-state) tr^)))

(tr code)

(c-call LLVMBuildRetVoid * * main-b)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err)))

(c-call LLVMDisposeBuilder void * main-b)

(print '
')
(c-call LLVMDumpModule void * m)
(if (= 0 (c-call LLVMPrintModuleToFile int * m * 'out.ll' * (c-ref err)))
    nil
    (print (c-str err)))
