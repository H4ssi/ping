; Copyright (C) 2015  Florian Hassanen
;
; This file is part of pint.
;
; pint is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; pint is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

(def pr (fn (x) (print (str (cons x ())))))
(def prln (fn (x) (print (str (cons x (cons '
' ()))))))

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'test' * c))
(def i (c-call LLVMInt32TypeInContext * * c))
(def ps (c-ptr-array (cons i (cons i ()))))
(def ft (c-call LLVMFunctionType * * i * ps int 2 int 0))
(def f (c-call LLVMAddFunction * * m * 'plus' * ft))
(def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
(def b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * b * bb)
(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))
(c-call LLVMBuildRet void * b * r)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(if (= 0 (c-call LLVMVerifyFunction int * f int LLVMPrintMessageAction))
    nil
    (prln 'error verifying function'))

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (prln (c-str err)))

(c-call LLVMDisposeBuilder void * b)

(c-call LLVMDumpModule void * m)

(c-call LLVMLinkInMCJIT void)
(c-call ExternLLVMInitializeNativeTarget void) ; todo inlining does not work :/
(c-call ExternLLVMInitializeNativeAsmPrinter void) 

(def ee (c-ref))

(if (= 0 (c-call LLVMCreateJITCompilerForModule int * (c-ref ee) * m int 0 * (c-ref err)))
    nil
    (prln (c-str err)))

(def plus (c-call LLVMGetPointerToGlobal * * ee * f))

(prln (str (cons 'calling ' (cons plus ()))))

(prln (str (cons '3 + 4 = ' (cons (c-call * plus int int 3 int 4) ()))))

(prln '')

; end of poc, start of pint

(def to-list
  (fn (string)

    (def to-list^
      (fn (pos rec)
        ((fn (c) (if (= c '') () (cons c (rec (+ pos 1) rec))))
         (substr string pos 1))))

    (to-list^ 0 to-list^)))

(def OP '(') ; ) (
(def CP ')')

(def newline '
')
(def whitespace (str (cons ' 	' (cons newline ()))))
(def digit '0123456789')

(def nil? (fn (w) (if w nil '')))
(def not  (fn (c) (if c nil '')))

(def and (fn (a b) (if a b a)))
(def or (fn (a b) (if a a b)))

(def empty? (fn (l) (if (tail l) nil l)))

(def pair
  (fn (l r)
    (cons l (cons r ()))))

(def unpair
 (fn (p f)
  (f (head p) (head (tail p)))))

(def fst (fn (p) (unpair p (fn (f s) f))))
(def snd (fn (p) (unpair p (fn (f s) s))))

(def uncons
 (fn (l f)
  (f (head l) (tail l))))

(def range
 (fn (l)
  (def range^
   (fn (r i i1 rec)
    (if (= i 0)
     r
     (rec (cons i1 r) i1 (+ i1 (- 1)) rec))))

  (range^ () l (+ l (- 1)) range^)))

(def reduce
  (fn (f i l)
    (def reduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (f (rec res (tail ll) rec) (head ll)))))

    (reduce^ i l reduce^)))

(def leduce
  (fn (f i l)
    (def leduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (rec (f res (head ll)) (tail ll) rec))))

    (leduce^ i l leduce^)))

(def listlen
  (fn (l)
    (leduce (fn (res i) (+ 1 res)) 0 l)))

(def strlen
  (fn (s) (listlen (to-list s))))

(def reverse
  (fn (l)
    (leduce (fn (res i) (cons i res)) () l)))

(def filter
  (fn (p l)
    (reduce 
      (fn (res i)
        (if (p i) (cons i res) res))
      ()
      l)))

(def map
  (fn (t l)
    (reduce
      (fn (res e)
        (cons (t e) res))
      ()
      l)))

(def stap
  (fn (t i l)
    (reduce
      (fn (st-res e) (unpair st-res (fn (st res) (unpair (t st e) (fn (st^ e^)
       (pair st^ (cons e^ res)))))))
      (pair i ())
      l)))

(def zip
 (fn (l r)
  (def zip^ (fn (ll rr rec)
             (if (empty? ll) ()
             (if (empty? rr) ()
             (uncons ll (fn (l-h l-t)
             (uncons rr (fn (r-h r-t)
             (cons (pair l-h r-h) (rec l-t r-t rec))))))))))
  (zip^ l r zip^)))

(def in-list
  (fn (e l)
    (not (empty? (filter (fn (i) (= i e)) l)))))   

(def in-str
  (fn (c string) (in-list c (to-list string))))

(def indexof (fn (el li)
 (def indexof^ (fn (l i rec)
  (if (empty? l)
   nil
   (uncons l (fn (h t)
    (if (= el h)
     i
     (rec t (+ i 1) rec)))))))
 (indexof^ li 0 indexof^)))

(def is-whitespace
  (fn (x) (in-str x whitespace)))
(def is-newline
  (fn (x) (in-str x newline)))
(def not-is-newline
  (fn (x) (not (is-newline x))))
(def is-digit
  (fn (x) (in-str x digit)))

(def t-ws
  (fn (x) (if (is-whitespace x) '_' x)))

(def drop-while 
  (fn (p l)
    
    (def drop-while^
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (rec (tail ll) rec)
            ll))))

    (drop-while^ l drop-while^)))

(def take-while
  (fn (p l)
    
    (def take-while^ 
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (cons (head ll) (rec (tail ll) rec))
            ()))))

    (take-while^ l take-while^)))

(def concat (fn (l r) (reduce (fn (ls el) (cons el ls)) r l)))

(def assoc 
 (fn (m k v)
  (cons k (cons v m))))

(def assocall (fn (m new-m) (concat new-m m)))

(def getk
 (fn (m k)
   (def getk^
     (fn (mm rec)
       (if (empty? mm)
         nil
         (if (= k (head mm))
            (head (tail mm))
            (rec (tail (tail mm)) rec)))))

   (getk^ m getk^)))

;(prln (getk () 'test')) ; should be nil
;(def testmap (assoc (assoc (assoc () 'a' 1) 'b' 2) 'a' 3))
;(prln (getk testmap 'a')) ; should be 3
;(prln (getk testmap 'b')) ; should be 2

(def split
 (fn (count list)
  
  (def split^
   (fn (list i rec)
    (if (= i count)
     (pair () list)
     (if (empty? list)
      (pair () nil)
      (unpair (rec (tail list) (+ i 1) rec)
       (fn (h t)
        (pair (cons (head list) h) t)))))))
  
  (split^ list 0 split^)))

(def take
 (fn (count list)
  (unpair (split count list)
   (fn (h t) h))))

(def drop
 (fn (count list)
  (unpair (split count list)
   (fn (h t) t))))

(def chunk
 (fn (chunk-size list)
  (def chunk^
   (fn (list rec)
    (unpair (split 2 list)
     (fn (h t)
      (if (nil? t)
       (pair () h)
       (if (empty? t)
        (pair (cons h ()) nil)
        (unpair (rec t rec)
         (fn (hh tt)
          (pair (cons h hh) tt)))))))))
  (chunk^ list chunk^)))

(def parse-sym 
  (fn (cs prs)
    (def sym-char
      (fn (c) (not (in-str c (str (cons whitespace (cons CP (cons OP (cons '\';' ())))))))))

    (pair 
      (symbol (str (take-while sym-char cs)))
      (drop-while sym-char cs))))

(def digit-to-number
  (fn (d)
    (if (= d '0') 0
    (if (= d '1') 1
    (if (= d '2') 2
    (if (= d '3') 3
    (if (= d '4') 4
    (if (= d '5') 5
    (if (= d '6') 6
    (if (= d '7') 7
    (if (= d '8') 8
    (if (= d '9') 9
    nil))))))))))))

(def parse-number
  (fn (cs prs)
    (def dec (take-while is-digit cs))
    (def r   (drop-while is-digit cs))
    
    (def rr  (if (empty? r) 
               r 
               (if (= '.' (head r)) 
                (tail r)
                r)))

    (def com (take-while is-digit rr))
    (def rrr (drop-while is-digit rr))

    (def n   (fn (l) (leduce (fn (nn dd) (+ (digit-to-number dd) (* 10 nn))) 0 l)))
    (def m   (fn (l) (leduce (fn (nn dd) (* 10 nn)) 1 l)))

    (pair (+ (n dec) (* (n com) (/ (m com)))) rrr)))
    
(def err (fn (x m) (error m) (pair (cons nil ()) x)))

(def parse-list 
  (fn (cs prs)
    (def parse-list^
      (fn (ccs rec)
        
        ((fn (p)
          (if (nil? p)
            (err ccs 'unexpected eof during list')
            ((fn (t r)
              (if (nil? t) ; end of list maybe?
                (if (empty? r)
                  (err ccs 'missing end of list')
                  (if (= CP (head r))
                    (pair () (tail r))
                    (err ccs (str (cons 'unexpected: ' (cons (head r) ()))))))
                ((fn (pp)
                ((fn (tt rr)
                  (pair (cons t tt) rr)
                )(head pp)(head (tail pp)))
                )(rec r rec)))
            )(head p)(head (tail p))))
        )(prs ccs prs))))

      (parse-list^ (tail cs) parse-list^)))

(def parse-string
  (fn (cs rec)
    (def pcons
      (fn (i p)
        (def f (head p))
        (def s (head (tail p)))

        (if f 
          (pair (cons i f) s)
          p)))

    (def escape 
      (fn (escape-next ccs rec)
        (if (empty? ccs)
          (err ccs 'unexpected eof during string')
          (if escape-next
            (pcons (head ccs) (rec nil (tail ccs) rec))
            (if (= '\\' (head ccs))
              (rec '' (tail ccs) rec)
              (if (= '\'' (head ccs))
                (pair () (tail ccs))
                (pcons (head ccs) (rec nil (tail ccs) rec))))))))

    (def e (escape nil (tail cs) escape))
    
    (def f (head e))
    (def s (head (tail e)))

    (pair (str (cons f ())) s)))

(def parse-expr
  (fn (cs rec)
    (if (empty? cs)
      nil
      ((fn (c)
        (if (is-whitespace c) (rec (drop-while is-whitespace cs) rec)
        (if (= c ';') (rec (drop-while not-is-newline cs) rec)
        (if (= c OP) (parse-list cs rec)
        (if (= c CP) (pair nil cs)
        (if (= c '\'') (parse-string cs rec)
        (if (is-digit c) (parse-number cs rec)
        (parse-sym cs rec)
        ))))))
      )(head cs)))))


(def parse-all
  (fn (cs rec)
    ((fn (p)
    (if (nil? p)
      ()
      ((fn (t r)
        (if (nil? t)
          (cons t ())
          (cons t (rec r rec)))
      )(head p)(head (tail p)))
    )
    )(parse-expr cs parse-expr))))

(def code (parse-all (to-list INPUT) parse-all))

; todo pretty print!
(prln code)

(def is-number (fn (o) (= o (+ 0 o))))
(def is-string (fn (o) (= o (str (cons o ())))))
(def is-symbol (fn (o) (= o (symbol (symbol-name o)))))
(def is-list (fn (o) (if (= o ()) o (tail o))))
(def is-fn (fn (o) (if o (not (= o o)) o)))

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'real' * c))

(def void-type (c-call LLVMVoidTypeInContext * * c))
(def i8-type (c-call LLVMInt8TypeInContext * * c))
(def i32-type (c-call LLVMInt32TypeInContext * * c))
(def i64-type (c-call LLVMInt64TypeInContext * * c))
(def float-type (c-call LLVMFloatTypeInContext * * c))
(def double-type (c-call LLVMDoubleTypeInContext * * c))
(def pointer-type (c-call LLVMPointerType * * i8-type int 0))

(def value-type (c-call LLVMStructCreateNamed * * c * 'value_type'))
(c-call LLVMStructSetBody void * value-type * (c-ptr-array (cons i64-type (cons i64-type ()))) int 2 int 0)

(def value-ptr-type (c-call LLVMPointerType * * value-type int 0))

(def list-elem-type (c-call LLVMStructCreateNamed * * c * 'list_elem_type'))
(c-call LLVMStructSetBody void * list-elem-type * (c-ptr-array (cons value-type (cons pointer-type ()))) int 2 int 0)

(def list-elem-ptr-type (c-call LLVMPointerType * * list-elem-type int 0))

(def frame-type (c-call LLVMStructCreateNamed * * c * 'frame_type'))
(c-call LLVMStructSetBody void
 * frame-type
 * (c-ptr-array (cons pointer-type (cons (c-call LLVMArrayType * * value-type int 0) ())))
 int 2
 int 0)

(def frame-ptr-type (c-call LLVMPointerType * * frame-type int 0))

(def void-type (c-call LLVMVoidTypeInContext * * c))

(def main-f-type (c-call LLVMFunctionType * * i32-type * (c-ptr-array ()) int 0 int 0))
(def main-f (c-call LLVMAddFunction * * m * 'main' * main-f-type))
(def main-bb (c-call LLVMAppendBasicBlockInContext * * c * main-f * 'entry'))
(def main-b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * main-b * main-bb)
;(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))

; state during code gen
; contains
;   "accumulator" (current-val)
;   current basic block (when joining on phi nodes we need to know the blocks we are joining from)
;   symbol table for each scope
;   globals
;   a list of borrowed values from an upper scope
; 2 kinds of scope are supported:
;   scope which can freely access parent scope
;   scope which needs to explicitly borrow refs from parent scope
; supported operations
;   set/get accumulator
;   set/get current basic block (set it on branching new states/new scopes)
;   set/get symbols from sym tab or globals
;   test whether there is an upper state to borrow from (am i root?)
;   borrow value from _some_ upper parent
;   branch new state (new scope)
;   merge back

(def state-make (fn (current-value
                     basic-block
                     parent-state    ; (direct) parent
                     borrow-ancestor ; ancestor to borrow from (maybe parent, maybe not)
                     symbol-table    ; one frame for each scope
                     borrowed-syms
                     globals)
                 (cons current-value
                 (cons basic-block
                 (cons parent-state
                 (cons borrow-ancestor
                 (cons symbol-table
                 (cons borrowed-syms
                 (cons globals ())))))))))

(def init-state (fn (bb) (state-make nil bb nil nil () nil ())))

(def state-unmake (fn (s f) (uncons s (fn (cv r)
                            (uncons r (fn (bb r)
                            (uncons r (fn (pt r)
                            (uncons r (fn (ba r)
                            (uncons r (fn (st r)
                            (uncons r (fn (bs r)
                            (uncons r (fn (gl r)
                            (f cv bb pt ba st bs gl)))))))))))))))))

(def state-cur-value (fn (s) (state-unmake s (fn (cv bb pt ba st bs gl) cv))))
(def state-set-cur-value (fn (s cv) (state-unmake s (fn (cv^ bb pt ba st bs gl)
                                    (state-make cv bb pt ba st bs gl)))))

(def state-bb (fn (s) (state-unmake s (fn (cv bb pt ba st bs gl) bb))))
(def state-set-bb (fn (s bb) (state-unmake s (fn (cv bb^ pt ba st bs gl)
                             (state-make cv bb pt ba st bs gl)))))


(def state-get-global (fn (s key) (state-unmake s (fn (cv bb pt ba st bs gl) (getk gl key)))))
(def state-add-global (fn (s key val) (state-unmake s (fn (cv bb pt ba st bs gl)
                                      (state-make cv bb pt ba st bs (assoc gl key val))))))

(def state-get-local (fn (s key) (state-unmake s (fn (cv bb pt ba st bs gl) (getk st key)))))
(def state-add-local (fn (s key val) (state-unmake s (fn (cv bb pt ba st bs gl)
                                     (state-make cv bb pt ba (assoc st key val) bs gl)))))

(def log (fn (lvl msg) (prln (str (cons '[' (cons lvl (cons '] ' (cons msg ()))))))))
(def debug (fn (msg) (log 'D' msg)))
(def info (fn (msg) (log 'I' msg)))
(def warn (fn (msg) (log 'W' msg)))
(def error (fn (msg) (log 'E' msg)))

(def state-borrow (fn (s sym)
 (def sb^ (fn (c rec)
  (if (nil? c)
   nil
   (state-unmake c (fn (cv bb pt ba st bs gl)
    (def ref (getk st sym))

    (if ref
     ref
     (rec ba rec)))))))

 (state-unmake s (fn (cv bb pt ba st bs gl)
  (if (in-list sym bs) ; already borrowed?
   s
   (if (or (sb^ ba sb^) (getk gl sym))
    (state-make cv bb pt ba st (reverse (cons sym (reverse bs))) gl)
    (error (str (cons 'undefined var: ' (cons (symbol-name sym) ()))))))))))

(def state-borrow-list (fn (s) (state-unmake s (fn (cv bb pt ba st bs gl) bs))))

(def state-can-borrow (fn (s) (state-unmake s (fn (cv bb pt ba st bs gl) ba))))

(def state-branch-direct (fn (s bb) (state-unmake s (fn (cv bb^ pt ba st bs gl)
                                    (state-make cv bb s ba st bs gl)))))
(def state-branch-borrow (fn (s bb) (state-unmake s (fn (cv bb^ pt ba st bs gl)
                                    (state-make cv bb s s () () gl)))))

(def state-branch-is-borrow (fn (s) (state-unmake s (fn (cv bb pt ba st bs gl) (= pt ba)))))

(def state-merge (fn (s)
                  (state-unmake s  (fn ( cv  bb  pt  ba  st  bs  gl)
                  (state-unmake pt (fn (pcv pbb ppt pba pst pbs pgl)
                   (if (state-branch-is-borrow s)
                    (state-make pcv pbb ppt pba pst pbs gl)
                    (state-make pcv pbb ppt pba pst  bs gl)))))))) ; todo merge strat for accumulator?

(def i32-const (fn (i) (c-call LLVMConstInt * * i32-type int i int 1)))
(def i64-const (fn (i) (c-call LLVMConstInt * * i64-type int i int 1)))

(def size-of-i64
 (fn (t n)
  (c-call LLVMBuildPtrToInt *
   * main-b
   * (c-call LLVMBuildGEP *
      * main-b
      * (c-call LLVMConstNull * * (c-call LLVMPointerType * * t int 0))
      * (c-ptr-array (cons (i64-const n) ()))
      int 1
      * 'size-of-ptr')
   * i64-type
   * 'size-of-i64')))

(def size-of-i32
 (fn (t n)
  (c-call LLVMBuildTrunc * * main-b * (size-of-i64 t n) * i32-type * 'size-of-i32')))

(def nil-type-index (i64-const 0)) ; type 0 = nil
(def number-type-index (i64-const 1)) ; type 1 = number
(def string-type-index (i64-const 2)) ; type 2 = string
(def list-type-index (i64-const 3)) ; type 3 = list
(def function-type-index (i64-const 4)) ; type 4 = function
(def c-pointer-type-index (i64-const 5)) ; type 5 = c-pointer

(def type-index-friendly-name (fn (idx) (if (= nil-type-index idx) 'nil'
                                        (if (= number-type-index idx) 'number'
                                        (if (= string-type-index idx) 'string'
                                        (if (= list-type-index idx) 'list'
                                        (if (= function-type-index idx) 'function'
                                        (if (= c-pointer-type-index idx) 'c-pointer'
                                        'value'))))))))

(def extract-with-index (fn (val index label) (c-call LLVMBuildExtractValue * * main-b * val int index * label)))
(def extract-type-index (fn (val label) (extract-with-index val 0 label)))
(def extract-value      (fn (val label) (extract-with-index val 1 label)))
(def extract-double     (fn (val label) (c-call LLVMBuildBitCast *
                                         * main-b
                                         * (extract-value val (str (cons label (cons '-int' ()))))
                                         * double-type
                                         * (str (cons label (cons '-double' ()))))))
(def extract-pointer    (fn (val type label) (c-call LLVMBuildIntToPtr *
                                              * main-b
                                              * (extract-value val (str (cons label (cons '-int' ()))))
                                              * type
                                              * (str (cons label (cons '-pointer' ()))))))

(def gep-with-index (fn (ptr index label)
                     (c-call LLVMBuildInBoundsGEP *
                      * main-b
                      * ptr
                      * (c-ptr-array (cons (i64-const 0) (cons (i32-const index) ())))
                     int 2
                     * label)))
(def gep-list-elem-val (fn (list-elem label) (gep-with-index list-elem 0 label)))
(def gep-list-elem-next (fn (list-elem label) (gep-with-index list-elem 1 label)))

(def tr-nil (fn (state)
 (state-set-cur-value state
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-ptr-array
        (cons nil-type-index
        (cons (c-call LLVMConstNull * * i64-type) ())))
    int 2))))

(def tr-number (fn (number state)
  (state-set-cur-value state
   (c-call LLVMConstNamedStruct *
     * value-type
     * (c-ptr-array
         (cons number-type-index
         (cons (c-call LLVMBuildBitCast * * main-b * (c-call LLVMConstReal * * double-type double number) * i64-type * 'pack-dbl') ())))
     int 2))))

(def tr-default (fn (state) (tr-number 1337 state))) ; todo raise error

(def tr-string (fn (string state)
 (def strval
   (c-call LLVMConstStringInContext * 
    * c
    * string
    int (+ (strlen string) 1)
    int 1)) ; do not zero terminate
 (def strmem
   (c-call LLVMAddGlobal *
    * m
    * (c-call LLVMTypeOf * * strval)
    * ''))
 (c-call LLVMSetGlobalConstant void * strmem int 1)
 (c-call LLVMSetInitializer void * strmem * strval)
 (state-set-cur-value state
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-ptr-array
        (cons string-type-index
        (cons (c-call LLVMBuildPtrToInt *
               * main-b
               * (c-call LLVMBuildInBoundsGEP *
                  * main-b
                  * strmem
                  * (c-ptr-array (cons (i64-const 0) ()))
                  int 1
                  * 'str to ptr')
               * i64-type
               * 'ptr to int') ())))
    int 2))))

(def tr-empty-list
 (fn (state)
  (state-set-cur-value state
   (c-call LLVMConstNamedStruct *
    * value-type
    * (c-ptr-array
       (cons list-type-index
       (cons (c-call LLVMConstNull * * i64-type) ())))
    int 2))))

(def tr-load-from-borrow
 (fn (sym state)
  (def s^ (state-borrow state sym))
  (if s^
   (do
    (def index (indexof sym (state-borrow-list s^)))
    (info (str (cons (symbol-name sym) (cons ' borrow index: ' (cons index ())))))
    (def val-loc (c-call LLVMBuildInBoundsGEP *
                  * main-b
                  * (state-get-local s^ '')
                  * (c-ptr-array (cons (i64-const index) ()))
                  int 1
                  * 'value-ptr'))
    (def val (c-call LLVMBuildLoad *
              * main-b
              * val-loc
              * 'value'))
    (state-set-cur-value (state-add-local s^ sym val) val))
   (warn (str (cons (symbol-name sym) (cons ' not found!' ())))))))

(def tr-load-from-global
 (fn (sym state)
  (def glb (state-get-global state sym))
    (if glb
     (unpair glb (fn (label val)
      (if (= 'var' label)
      (state-set-cur-value state (c-call LLVMBuildLoad * * main-b * val * 'load_from_var'))
       (error (str (cons 'expected ' (cons (symbol-name sym) (cons ' to be a variable, actually is ' (cons label ())))))))))
    (error (str (cons 'unknown variable ' (cons (symbol-name sym) ())))))))

(def tr-load
 (fn (sym state)
  (def lcl (state-get-local state sym))
  (if lcl
   (state-set-cur-value state lcl)
   (if (state-can-borrow state)
    (tr-load-from-borrow sym state)
    (tr-load-from-global sym state)))))

; LLVMTypeKind
(def LLVMVoidTypeKind 0) ; type with no size
(def LLVMHalfTypeKind 1) ; 16 bit floating point type
(def LLVMFloatTypeKind 2) ; 32 bit floating point type
(def LLVMDoubleTypeKind 3) ; 64 bit floating point type
(def LLVMX86_FP80TypeKind 4) ; 80 bit floating point type (X87)
(def LLVMFP128TypeKind 5) ; 128 bit floating point type (112-bit mantissa)
(def LLVMPPC_FP128TypeKind 6) ; 128 bit floating point type (two 64-bits)
(def LLVMLabelTypeKind 7) ; Labels
(def LLVMIntegerTypeKind 8) ; Arbitrary bit width integers
(def LLVMFunctionTypeKind 9) ; Functions
(def LLVMStructTypeKind 10) ; Structures
(def LLVMArrayTypeKind 11) ; Arrays
(def LLVMPointerTypeKind 12) ; Pointers
(def LLVMVectorTypeKind 13) ; SIMD 'packed' format, or other vector type
(def LLVMMetadataTypeKind 14) ; Metadata
(def LLVMX86_MMXTypeKind 15) ; X86 MMX

(def tr-c-type
 (fn (type)
  (if (= (symbol 'void') type)
   void-type
  (if (= (symbol 'char') type)
   i8-type
  (if (= (symbol 'uchar') type)
   i8-type
  (if (= (symbol 'int') type)
   i32-type
  (if (= (symbol 'uint') type)
   i32-type
  (if (= (symbol 'float') type)
   float-type
  (if (= (symbol 'double') type)
   double-type
  (if (= (symbol '*') type)
   pointer-type
   double-type))))))))))

(def tr-cast-from-nil-to-c-type
 (fn (type val) (c-call LLVMConstNull * * (tr-c-type type))))

(def is-type-unsigned (fn (type) (= 'u' (substr (symbol-name type) 0 1))))

(def tr-cast-from-number-to-c-type
 (fn (type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str (cons 'unpack-' (cons (symbol-name type) ()))))

  (def get-val (fn () (extract-double val 'value')))

  (if (= kind LLVMIntegerTypeKind)
   (if (is-type-unsigned type)
    (c-call LLVMBuildFPToUI * * main-b * (get-val) * c-type * label)
    (c-call LLVMBuildFPToSI * * main-b * (get-val) * c-type * label))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (c-call LLVMBuildFPTrunc * * main-b * (get-val) * c-type * label)
  (if (= kind LLVMDoubleTypeKind)
   (get-val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (c-call LLVMBuildFPExt * * main-b * (get-val) * c-type * label)
   (c-call LLVMConstNull * * c-type)))))))

(def tr-cast-if-target-c-type-is-pointer
 (fn (type val)
  (if (= (symbol '*') type)
   (extract-pointer val pointer-type 'ptr-to-data')
   (c-call LLVMConstNull * * (tr-c-type type)))))

(def tr-cast-from-string-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-c-pointer-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-function-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-from-list-to-c-type tr-cast-if-target-c-type-is-pointer)

(def tr-cast-to-c-type ; todo write tests for all combinations!
 (fn (state type val)
  (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

  (def dyn-type (extract-type-index val 'dyn-type'))
  (def merge-block (c-call LLVMAppendBasicBlockInContext * * c * f * 'merge'))

  (def c-pointer-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'c-pointer-cast'))
  (def switch (c-call LLVMBuildSwitch * * main-b * dyn-type * c-pointer-cast-bb int 5))

  ; cast from nil
  (def nil-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'nil-cast'))
  (c-call LLVMAddCase void * switch * nil-type-index * nil-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * nil-cast-bb)
  (def nil-cast-v (tr-cast-from-nil-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from number
  (def number-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'number-cast'))
  (c-call LLVMAddCase void * switch * number-type-index * number-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * number-cast-bb)
  (def number-cast-v (tr-cast-from-number-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from string
  (def string-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'string-cast'))
  (c-call LLVMAddCase void * switch * string-type-index * string-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * string-cast-bb)
  (def string-cast-v (tr-cast-from-string-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; cast from list
  (def list-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'list-cast'))
  (c-call LLVMAddCase void * switch * list-type-index * list-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * list-cast-bb)
  (def list-cast-v (tr-cast-from-list-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)
  
  ; cast from function
  (def function-cast-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'function-cast'))
  (c-call LLVMAddCase void * switch * function-type-index * function-cast-bb)
  (c-call LLVMPositionBuilderAtEnd void * main-b * function-cast-bb)
  (def function-cast-v (tr-cast-from-function-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)

  ; default must be cast from c-pointer
  (c-call LLVMPositionBuilderAtEnd void * main-b * c-pointer-cast-bb)
  (def c-pointer-cast-v (tr-cast-from-c-pointer-to-c-type type val))
  (c-call LLVMBuildBr * * main-b * merge-block)
  
  (c-call LLVMPositionBuilderAtEnd void * main-b * merge-block)

  (def phi (c-call LLVMBuildPhi * * main-b * (tr-c-type type) * 'c-value'))

  (c-call LLVMAddIncoming void
   * phi
   * (c-ptr-array
      (cons nil-cast-v
      (cons number-cast-v
      (cons string-cast-v
      (cons list-cast-v
      (cons function-cast-v
      (cons c-pointer-cast-v ())))))))
   * (c-ptr-array
      (cons nil-cast-bb
      (cons number-cast-bb
      (cons string-cast-bb
      (cons list-cast-bb
      (cons function-cast-bb
      (cons c-pointer-cast-bb ())))))))
   int 6)

  (state-set-bb
   (state-set-cur-value state phi)
   merge-block)))

(def build-val
 (fn (type-id val)
  (c-call LLVMBuildInsertValue *
          * main-b
          * (c-call LLVMConstNamedStruct *
                    * value-type
                    * (c-ptr-array (cons type-id (cons (c-call LLVMGetUndef * * i64-type) ())))
                    int 2)
          * (c-call LLVMBuildBitCast *
                    * main-b
                    * val
                    * i64-type
                    * 'convert-to-i64')
          int 1
          * (str (cons 'packed-' (cons (type-index-friendly-name type-id) ()))))))

(def tr-cast-from-c-type
 (fn (state type val)
  (def c-type (tr-c-type type))

  (def kind (c-call LLVMGetTypeKind int * c-type))

  (def label (str (cons 'cast-' (cons (symbol-name type) ()))))

  (if (= kind LLVMPointerTypeKind)
   (build-val c-pointer-type-index (c-call LLVMBuildPtrToInt * * main-b * val * i64-type * 'ptr-to-int'))
  (if (= kind LLVMIntegerTypeKind)
   (build-val number-type-index
    (if (is-type-unsigned type)
     (c-call LLVMBuildUIToFP * * main-b * val * double-type * label)
     (c-call LLVMBuildSIToFP * * main-b * val * double-type * label)))
  (if (or
       (= kind LLVMHalfTypeKind)
       (= kind LLVMFloatTypeKind))
   (build-val number-type-index (c-call LLVMBuildFPExt * * main-b * val * double-type * label))
  (if (= kind LLVMDoubleTypeKind)
   (build-val number-type-index val)
  (if (or
       (= kind LLVMX86_FP80TypeKind)
      (or
       (= kind LLVMFP128TypeKind)
       (= kind LLVMPPC_FP128TypeKind)))
   (build-val number-type-index (c-call LLVMBuildFPTrunc * * main-b * val * double-type * label))
   (c-call LLVMConstNull * * value-type)))))))) ; todo handle non numeric, non pointer types (are there any?)

(def tr-declare-c-fn
 (fn (name ret-type arg-types)
  (def ret-c-type (tr-c-type ret-type))

  (def c-typed-args (map (fn (type) (tr-c-type type)) arg-types))
  (def num-args (listlen c-typed-args))
  
  (def arg-t-array (c-ptr-array c-typed-args))
  (def fn-t (c-call LLVMFunctionType * * ret-c-type * arg-t-array int num-args int 0))

  (c-call LLVMAddFunction * * m * (symbol-name name) * fn-t)))

(def tr-declare-c-var
 (fn (name)
  (debug (str (cons 'declaring glb var: ' (cons (symbol-name name) ()))))
  (c-call LLVMAddGlobal * * m * pointer-type * (symbol-name name))))

(def state-add-global-tagged (fn (state key tag thing)
 (state-add-global state key (pair tag thing))))

(def c-fn-tag 'c-fn')
(def c-var-tag 'c-var')

(def state-add-global-fn (fn (state fn-name ret-type arg-types)
 (state-add-global-tagged state fn-name c-fn-tag (tr-declare-c-fn fn-name ret-type arg-types))))

(def state-add-global-var (fn (state var-name)
 (state-add-global-tagged state var-name c-var-tag (tr-declare-c-var var-name))))

(def tr-c-call
 (fn (form state tr)
  (def fn-name (head (tail form)))

  (def ret-type (head (tail (tail form))))
  (def typed-args (chunk 2 (tail (tail (tail form))))) ; care for wrongly chunked!

  (def state^
   (if (state-get-global state fn-name)
    state
    (state-add-global-fn state fn-name ret-type (map fst (head typed-args)))))

  (def entry (state-get-global state^ fn-name))

  (def target-fn (unpair entry (fn (label val)
                                (if (= label c-fn-tag)
                                 val
                                 (error (str (cons 'not a C fn: ' (cons (symbol-name fn-name) ()))))))))

  (def casts (stap (fn (st typed-arg)
                    (unpair typed-arg
                     (fn (type arg)
                      (def st^ (tr (cons arg ()) st tr))
                      (def st^^ (tr-cast-to-c-type st^ type (state-cur-value st^)))
                      (pair st^^ (state-cur-value st^^)))))
                   state^
                   (reverse (head typed-args))))

  (def state^^ (fst casts))
  (def c-casted-args (reverse (snd casts)))

  (def num-args (listlen c-casted-args))

  (def is-void (= (symbol 'void') ret-type))
  (def res (c-call LLVMBuildCall *
            * main-b
            * target-fn
            * (c-ptr-array c-casted-args)
            int num-args
            * (if is-void '' (str (cons 'call-' (cons (symbol-name fn-name) ()))))))

  (if is-void
   (tr-nil state^^)
   (state-set-cur-value state^^
    (tr-cast-from-c-type state^^ ret-type res)))))

(def tr-c-val-ref
 (fn (form state tr)

  ; todo check num args
  (def val-name (head (tail form)))

  (def state^
   (if (state-get-global state val-name)
    state
    (state-add-global-var state val-name)))

  (def entry (state-get-global state^ val-name))

  (def target-val (unpair entry (fn (label val)
                                 (if (= label c-var-tag)
                                  val
                                  (error (str (cons 'not a C var: ' (cons (symbol-name val-name) ()))))))))

  (def c-ptr-val (build-val
                  c-pointer-type-index
                  (c-call LLVMBuildPtrToInt *
                   * main-b
                   * target-val
                   * i64-type
                   * 'ptr-as-i64')))

  (state-set-cur-value state^ c-ptr-val)))


; LLVMIntPredicate
(def LLVMIntEQ 32)  ; equal
(def LLVMIntNE 33)  ; not equal
(def LLVMIntUGT 34) ; unsigned greater than
(def LLVMIntUGE 35) ; unsigned greater or equal
(def LLVMIntULT 36) ; unsigned less than
(def LLVMIntULE 37) ; unsigned less or equal
(def LLVMIntSGT 38) ; signed greater than
(def LLVMIntSGE 39) ; signed greater or equal
(def LLVMIntSLT 40) ; signed less than
(def LLVMIntSLE 41) ; signed less or equal

(def tr-if
 (fn (form state tr)
  (if (not (= (listlen form) 4))
   (error 'expected: if <cond> <then> <else>')

   (uncons (tail form) (fn (cond r)
   (uncons r (fn (then r)
   (uncons r (fn (else r)

   (def s^ (tr (cons cond ()) state tr))

   (def cond-v (state-cur-value s^))

   (def cond-true? (c-call LLVMBuildICmp * * main-b int LLVMIntNE * (extract-type-index cond-v 'if-cond-type') * nil-type-index * 'if-cond'))

   (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

   (def then-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-then'))
   (def else-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-else'))
   (def merge-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'if-merge'))

   (c-call LLVMBuildCondBr * * main-b * cond-true? * then-bb * else-bb)

   (c-call LLVMPositionBuilderAtEnd void * main-b * then-bb)
   (def s^then (tr (cons then ()) (state-branch-direct s^ then-bb) tr))
   (def s^^ (state-merge s^then))
   (c-call LLVMBuildBr * * main-b * merge-bb)


   (c-call LLVMPositionBuilderAtEnd void * main-b * else-bb)
   (def s^else (tr (cons else ()) (state-branch-direct s^^ else-bb) tr))
   (def s^^^ (state-merge s^else))
   (c-call LLVMBuildBr * * main-b * merge-bb)

   (c-call LLVMPositionBuilderAtEnd void * main-b * merge-bb)

   (def phi (c-call LLVMBuildPhi * * main-b * value-type * 'if-result'))

   (c-call LLVMAddIncoming void
    * phi
    * (c-ptr-array
       (cons (state-cur-value s^then)
       (cons (state-cur-value s^else) ())))
    * (c-ptr-array
       (cons (state-bb s^then)
       (cons (state-bb s^else) ())))
   int 2)

   (state-set-bb
    (state-set-cur-value s^^^ phi)
    merge-bb))))))))))

(def get-fn-type
 (fn (num-args)
   (def arg-t-array (c-ptr-array (cons value-ptr-type (map (fn (arg) value-type) (range num-args)))))

   (c-call LLVMFunctionType * * value-type * arg-t-array int (+ num-args 1) int 0)))

(def gen-fn
 (fn (num-args gen-body)
  (def fn-t (get-fn-type num-args))

  (def f (c-call LLVMAddFunction * * m * '' * fn-t))

  (def prev (c-call LLVMGetInsertBlock * * main-b))

  (def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
  (c-call LLVMPositionBuilderAtEnd void * main-b * bb)

  (def frame-reg (c-call LLVMGetParam * * f int 0))
  (def arg-regs (map (fn (i) (c-call LLVMGetParam * * f int (+ i 1))) (range num-args)))

  (def ret (gen-body frame-reg arg-regs bb))

  (c-call LLVMPositionBuilderAtEnd void * main-b * prev)

  (pair f ret)))

(def gen-fn-frame
 (fn (state f borrowed-vars)
   (info (str (cons 'assembling closure frame: ' (cons borrowed-vars ()))))
   (def borrowed-vars-num (listlen borrowed-vars))
   (def frame-size (+ 8 (* 16 borrowed-vars-num)))
   (def frame-mem (c-call LLVMBuildCall *
                   * main-b
                   * (snd (state-get-global state (quote malloc)))
                   * (c-ptr-array (cons (i32-const frame-size) ()))
                   int 1
                   * 'alloc-frame'))
   ; todo memory management & free!!!
   (def frame (c-call LLVMBuildBitCast * * main-b * frame-mem * frame-ptr-type * 'cast-to-frame-ptr'))
   (c-call LLVMBuildStore *
    * main-b
    * (c-call LLVMBuildBitCast * * main-b * f * pointer-type * 'cast-f-to-f-tpr')
    * (c-call LLVMBuildInBoundsGEP * * main-b * frame * (c-ptr-array (cons (i64-const 0) (cons (i32-const 0) ()))) int 2 * 'func-ptr-loc'))
   (def state^
    (leduce (fn (st borrowed)
             (unpair borrowed (fn (i b)
              (def st^ (tr-load b st))
              ; todo codegen store load into frame
              (def loc (c-call LLVMBuildInBoundsGEP *
                        * main-b
                        * frame
                        * (c-ptr-array (cons (i64-const 0) (cons (i32-const 1) (cons (i64-const i) ()))))
                        int 3
                        * (str (cons 'capture-' (cons (symbol-name b) (cons '-addr' ()))))))
              (c-call LLVMBuildStore * * main-b * (state-cur-value st^) * loc)
              st^)))
            state
            (zip (range borrowed-vars-num) borrowed-vars)))
   (info 'done')

   (def func-pointer (c-call LLVMBuildPtrToInt * * main-b * frame * i64-type * 'pack-closure'))

   (state-set-cur-value state^ (build-val function-type-index func-pointer))))

(def tr-fn
 (fn (form state tr)
  ; todo check length ok

  (uncons (tail form) (fn (args body)
   (def num-args (listlen args))

   (unpair
    (gen-fn num-args
     (fn (frame-reg arg-regs bb)
      (def local-state (state-branch-borrow state bb))

      (def local-state^
       (leduce (fn (st arg)
                (unpair arg (fn (sym reg)
                 (state-add-local st sym reg))))
               (state-add-local local-state '' frame-reg)
               (zip args arg-regs)))

      (def local-state^^ (tr body local-state^ tr))

      (c-call LLVMBuildRet * * main-b * (state-cur-value local-state^^)) ; todo care for empty body

      local-state^^))
    (fn (f local-state^^)
     (def state^ (state-merge local-state^^))
     (gen-fn-frame state^ f (state-borrow-list local-state^^))))))))

(def tr-def-local
 (fn (name state)
  (state-add-local state name (state-cur-value state))))

(def tr-def-global
 (fn (name state)

  (def val (state-cur-value state))

  (def state^
     (if (state-get-global state name)
       state
       (do
         (def var (c-call LLVMAddGlobal * * m * value-type * (symbol-name name)))
         (c-call LLVMSetInitializer void * var *
          (if (= 0 (c-call LLVMIsConstant int * val))
           (c-call LLVMConstNull * * value-type)
           val))

         (state-add-global state name (pair 'var' var)))))

  (def gl-var (unpair (state-get-global state^ name)
               (fn (label var)
                (if (= 'var' label)
                 var
                 (error (str (cons 'expected ' (cons (symbol-name name) (cons ' to be a variable, but actually is ' (cons label ()))))))))))

  (c-call LLVMBuildStore * * main-b * val * gl-var)

  state^))

(def tr-def
 (fn (form state tr)
  (def name (head (tail form)))

  (def build (fn ()
   (def val (head (tail (tail form))))

   (if (nil? val)
    (tr-nil state)
    (tr (cons val ()) state tr))))

  (if (state-can-borrow state) ; is local var enough?
   (tr-def-local name (build))
   (tr-def-global name (build)))))

(def tr-call
 (fn (form state tr)
  ; todo check for length

  (uncons form (fn (f args)

  (def f-state (tr (cons f ()) state tr))

  (def args-state (stap (fn (st arg)
                        (def st^ (tr (cons arg ()) st tr))
                        (pair st^ st^)) ; todo do list in cur-val instead?
                   f-state
                   (reverse args)))

  (def state^ (fst args-state))
  (def arg-states (reverse (snd args-state)))

  (def num-args (listlen arg-states))

  (def f-type (get-fn-type num-args))
  (def f-ptr-type (c-call LLVMPointerType * * f-type int 0))

  (def frame-ptr (extract-pointer (state-cur-value f-state) frame-ptr-type 'fn-frame-addr'))

  (def target-fn-loc (c-call LLVMBuildInBoundsGEP *
                      * main-b
                      * frame-ptr
                      * (c-ptr-array (cons (i64-const 0) (cons (i32-const 0) ())))
                      int 2
                      * 'fn-addr'))

  (def borrowed-vals-loc (c-call LLVMBuildInBoundsGEP *
                          * main-b
                          * frame-ptr
                          * (c-ptr-array (cons (i64-const 0) (cons (i32-const 1) (cons (i64-const 0) ()))))
                          int 3
                          * 'borrowed-vals-addr'))

  (def target-fn (c-call LLVMBuildBitCast *
                  * main-b
                  * (c-call LLVMBuildLoad * * main-b * target-fn-loc * 'fn-ptr-void-ptr-type')
                  * f-ptr-type
                  * 'fn-ptr'))

  ; todo call with frame
  (def res (c-call LLVMBuildCall *
            * main-b
            * target-fn
            * (c-ptr-array (cons borrowed-vals-loc (map state-cur-value arg-states)))
            int (+ num-args 1)
            * 'call-fn'))

  (state-set-cur-value state^ res)))))

(def tr-c-array
 (fn (form state tr)
  ; todo check for length
  (uncons (tail form) (fn (type r)
  (uncons r           (fn (num  _)

   (def c-type (tr-c-type type))

   (def array-mem (c-call LLVMBuildCall *
                   * main-b
                   * (snd (state-get-global state (quote malloc)))
                   * (c-ptr-array (cons (size-of-i32 c-type num) ()))
                   int 1
                   * 'alloc-array'))

   (def array-addr (c-call LLVMBuildPtrToInt *
                    * main-b
                    * array-mem
                    * i64-type
                    * 'array-addr'))

   (state-set-cur-value state (build-val c-pointer-type-index array-addr))))))))

(def tr-c-array-addr
 (fn (type index ptr)
  (def c-type (tr-c-type type))

  (def idx-int (c-call LLVMBuildFPToUI *
                * main-b
                * (extract-double index 'idx-dbl')
                * i64-type
                * 'idx-i64'))

  (c-call LLVMBuildGEP *
   * main-b
   * (c-call LLVMBuildIntToPtr *
      * main-b
      * (extract-value ptr 'ptr-i64')
      * (c-call LLVMPointerType * * c-type int 0)
      * 'ptr')
   * (c-ptr-array (cons idx-int ()))
   int 1
   * 'array-cell')))

(def tr-c-array-set
 (fn (form state tr)
  ; todo check for length
  (uncons (tail form) (fn (type r)
  (uncons r           (fn (index r)
  (uncons r           (fn (array r)
  (uncons r           (fn (value r)

  (def idx (tr (cons index ()) state tr))

  (def ptr (tr (cons array ()) idx tr))

  (def val (tr (cons value ()) ptr tr))

  (def addr (tr-c-array-addr type (state-cur-value idx) (state-cur-value ptr)))

  (def casted-val (tr-cast-to-c-type val type (state-cur-value val)))

  (c-call LLVMBuildStore *
   * main-b
   * (state-cur-value casted-val)
   * addr)

  casted-val))))))))))

(def tr-c-array-get
 (fn (form state tr)
  ; todo check for length
  (uncons (tail form) (fn (type r)
  (uncons r           (fn (index r)
  (uncons r           (fn (array r)

  (def idx (tr (cons index ()) state tr))

  (def ptr (tr (cons array ()) idx tr))

  (def addr (tr-c-array-addr type (state-cur-value idx) (state-cur-value ptr)))

  (def val (c-call LLVMBuildLoad *
            * main-b
            * addr
            * 'loaded-val'))

  (state-set-cur-value
   ptr
   (tr-cast-from-c-type ptr type val))))))))))

(def tr-form
 (fn (form state tr)
   (if (empty? form)
     (tr-empty-list state)

   (if (= (symbol 'def') (head form))
     (tr-def form state tr)

   (if (= (symbol 'c-call') (head form))
     (tr-c-call form state tr)

   (if (= (symbol 'c-val-ref') (head form))
     (tr-c-val-ref form state tr)

   (if (= (symbol 'c-array') (head form))
     (tr-c-array form state tr)

   (if (= (symbol 'c-array-set') (head form))
     (tr-c-array-set form state tr)

   (if (= (symbol 'c-array-get') (head form))
     (tr-c-array-get form state tr)

   (if (= (symbol 'if') (head form))
     (tr-if form state tr)

   (if (= (symbol 'fn') (head form))
     (tr-fn form state tr)

   (tr-call form state tr))))))))))))

(def tr-type-test
 (fn (type-index val)
  (c-call LLVMBuildICmp *
   * main-b
   int LLVMIntEQ
   * (extract-type-index val 'type-index')
   * type-index
   * (str (cons 'is-' (cons (type-index-friendly-name type-index) ()))))))

(def tr
  (fn (code)
    (def s-malloc (state-add-global-fn (init-state main-bb) (quote malloc) (quote *) (cons (quote uint) ())))

    (def built-in-fn
     (fn (state name num-args body)
      (def f (fst (gen-fn num-args (fn (frame args bb) (body args)))))
      (def f-val (state-cur-value (gen-fn-frame state f ())))
      (state-add-local state name f-val)))

    (def s-cons
     (built-in-fn s-malloc (quote cons) 2 (fn (args) (unpair args (fn (e l)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))

      (def is-list (tr-type-test list-type-index l))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def alloc (c-call LLVMBuildCall *
                  * main-b
                  * (snd (state-get-global s-malloc (quote malloc)))
                  * (c-ptr-array (cons (i32-const 24) ()))
                  int 1
                  * 'list-elem-mem-void-ptr'))

      (def list-elem-mem (c-call LLVMBuildBitCast *
                          * main-b
                          * alloc
                          * list-elem-ptr-type
                          * 'list-elem-mem'))

      (c-call LLVMBuildStore *
       * main-b
       * e
       * (gep-list-elem-val list-elem-mem 'list-elem-val-ptr'))
      (c-call LLVMBuildStore *
       * main-b
       * (extract-pointer l pointer-type 'ptr-to-prev-head')
       * (gep-list-elem-next list-elem-mem 'list-elem-next-ptr'))

      (def new-l (build-val list-type-index (c-call LLVMBuildPtrToInt * * main-b * list-elem-mem * i64-type * 'cast-to-int')))

      (c-call LLVMBuildRet * * main-b * new-l)

      nil)))))

    (def s-head
     (built-in-fn s-cons (quote head) 1 (fn (args) (uncons args (fn (l _)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))
      (def not-empty-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'not-empty'))

      (def is-list (tr-type-test list-type-index l))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def head-ptr (extract-pointer l list-elem-ptr-type 'head'))

      (def is-empty (c-call LLVMBuildIsNull * * main-b * head-ptr * 'is-empty'))

      (c-call LLVMBuildCondBr * * main-b * is-empty * nil-bb * not-empty-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * not-empty-bb)

      (def head-val (c-call LLVMBuildLoad *
                     * main-b
                     * (gep-list-elem-val head-ptr 'head-val-ptr')
                     * 'head-val'))

      (c-call LLVMBuildRet * * main-b * head-val)

      nil)))))

    (def s-tail
     (built-in-fn s-head (quote tail) 1 (fn (args) (uncons args (fn (l _)
      (def f (c-call LLVMGetBasicBlockParent * * (c-call LLVMGetInsertBlock * * main-b)))

      (def nil-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-nil'))
      (def list-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'is-list'))
      (def not-empty-bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'not-empty'))

      (def is-list (tr-type-test list-type-index l))

      (c-call LLVMBuildCondBr * * main-b * is-list * list-bb * nil-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * nil-bb)

      (c-call LLVMBuildRet * * main-b * (state-cur-value (tr-nil s-malloc)))

      (c-call LLVMPositionBuilderAtEnd void * main-b * list-bb)

      (def head-ptr (extract-pointer l list-elem-ptr-type 'head'))

      (def is-empty (c-call LLVMBuildIsNull * * main-b * head-ptr * 'is-empty'))

      (c-call LLVMBuildCondBr * * main-b * is-empty * nil-bb * not-empty-bb)

      (c-call LLVMPositionBuilderAtEnd void * main-b * not-empty-bb)

      (def head-next (c-call LLVMBuildLoad *
                      * main-b
                      * (gep-list-elem-next head-ptr 'head-next-ptr')
                      * 'head-next'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val list-type-index (c-call LLVMBuildPtrToInt * * main-b * head-next * i64-type * 'cast-to-int')))

      nil)))))

    (def zero (c-call LLVMConstNull * * double-type))
    (def one (c-call LLVMConstRealOfString * * double-type * '1'))
    (def num-or-default (fn (v d)
                         (c-call LLVMBuildSelect *
                          * main-b
                          * (tr-type-test number-type-index v)
                          * (extract-double v 'number')
                          * d
                          * 'num-or-default')))
    (def num-or-zero (fn (v) (num-or-default v zero)))
    (def num-or-one (fn (v) (num-or-default v one)))

    (def s-+
     (built-in-fn s-tail (quote +) 2 (fn (args) (unpair args (fn (l r)
      (def s zero)

      (def s^  (c-call LLVMBuildFAdd * * main-b * s  * (num-or-zero l) * 's1'))
      (def s^^ (c-call LLVMBuildFAdd * * main-b * s^ * (num-or-zero r) * 's2'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val number-type-index (c-call LLVMBuildBitCast * * main-b * s^^ * i64-type * 'pack-dbl')))

      nil)))))

    (def s-*
     (built-in-fn s-+ (quote *) 2 (fn (args) (unpair args (fn (l r)
      (def p one)

      (def p^  (c-call LLVMBuildFMul * * main-b * p  * (num-or-one l) * 'p1'))
      (def p^^ (c-call LLVMBuildFMul * * main-b * p^ * (num-or-one r) * 'p2'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val number-type-index (c-call LLVMBuildBitCast * * main-b * p^^ * i64-type * 'pack-dbl')))

      nil)))))

    (def s--
     (built-in-fn s-* (quote -) 1 (fn (args) (uncons args (fn (n _)
      (def d zero)

      (def d^ (c-call LLVMBuildFSub * * main-b * d * (num-or-zero n) * 'diff'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val number-type-index (c-call LLVMBuildBitCast * * main-b * d^ * i64-type * 'pack-dbl')))

      nil)))))

    (def s-/
     (built-in-fn s-- (quote /) 1 (fn (args) (uncons args (fn (n _)
      (def q one)

      (def q^ (c-call LLVMBuildFDiv * * main-b * q * (num-or-one n) * 'quot'))

      (c-call LLVMBuildRet *
       * main-b
       * (build-val number-type-index (c-call LLVMBuildBitCast * * main-b * q^ * i64-type * 'pack-dbl')))

      nil)))))

    (def s-type
     (built-in-fn s-/ (quote p/type) 1 (fn (args) (uncons args (fn (v _)
      (c-call LLVMBuildRet *
       * main-b
       * (build-val number-type-index (c-call LLVMBuildUIToFP *
                                       * main-b
                                       * (extract-type-index v 'type-index')
                                       * double-type
                                       * 'type-index-as-double')))
      nil)))))

    (def s-ident
     (built-in-fn s-type (quote p/ident) 2 (fn (args) (unpair args (fn (l r)
      (def t-eq (c-call LLVMBuildICmp *
                 * main-b
                 int LLVMIntEQ
                 * (extract-type-index l 'l-type')
                 * (extract-type-index r 'r-type')
                 * 't-eq'))

      (def v-eq (c-call LLVMBuildICmp *
                 * main-b
                 int LLVMIntEQ
                 * (extract-value l 'l-val')
                 * (extract-value r 'r-val')
                 * 'v-eq'))

      (def t-ok (c-call LLVMBuildSelect *
                 * main-b
                 * t-eq
                 * l
                 * (state-cur-value (tr-nil s-type))
                 * 't-ok'))

      (def v-ok (c-call LLVMBuildSelect *
                 * main-b
                 * v-eq
                 * t-ok
                 * (state-cur-value (tr-nil s-type))
                 * 'v-ok'))
      
      (c-call LLVMBuildRet * * main-b * v-ok)

      nil)))))

    (def s-c-str
     (built-in-fn s-ident (quote c-str) 1 (fn (args) (uncons args (fn (v _)
      (c-call LLVMBuildRet *
       * main-b
       * (build-val string-type-index (extract-value v 'str-data-ptr')))

      nil)))))

    (def s s-c-str)

    (def tr^ (fn (c state rec)
      (if (empty? c)
       state
       ((fn (h t)
         (def state
            (if (is-list h)
             (tr-form h state rec)
            (if (is-string h)
             (tr-string h state)
            (if (is-number h)
             (tr-number h state)
            (if (is-symbol h)
             (tr-load h state)
             (tr-default state)))))) ; todo other options
         (rec t state rec)
       ) (head c) (tail c)))))

    (def exit-code (state-cur-value (tr^ code s tr^)))

    (c-call LLVMBuildRet *
     * main-b
     * (c-call LLVMBuildSelect *
        * main-b
        * (tr-type-test number-type-index exit-code)
        * (c-call LLVMBuildFPToSI *
           * main-b
           * (extract-double exit-code 'exit-code-double')
           * i32-type
           * 'exit-code-i32')
        * (c-call LLVMBuildTrunc *
           * main-b
           * (extract-value exit-code 'exit-code-i64')
           * i32-type
           * 'exit-code-i32')
        * 'exit-code'))))

(tr code)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (prln (c-str err)))

(c-call LLVMDisposeBuilder void * main-b)

(prln '')

(c-call LLVMDumpModule void * m)
(if (= 0 (c-call LLVMPrintModuleToFile int * m * 'out.ll' * (c-ref err)))
    nil
    (prln (c-str err)))
