; Copyright (C) 2015  Florian Hassanen
;
; This file is part of pint.
;
; pint is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; pint is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'test' * c))
(def i (c-call LLVMInt32TypeInContext * * c))
(def ps (c-array i i))
(def ft (c-call LLVMFunctionType * * i * ps int 2 int 0))
(def f (c-call LLVMAddFunction * * m * 'plus' * ft))
(def bb (c-call LLVMAppendBasicBlockInContext * * c * f * 'entry'))
(def b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * b * bb)
(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))
(c-call LLVMBuildRet void * b * r)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(if (= 0 (c-call LLVMVerifyFunction int * f int LLVMPrintMessageAction))
    nil
    (print 'error verifying function'))

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err)))

(c-call LLVMDisposeBuilder void * b)

(c-call LLVMDumpModule void * m)

(c-call LLVMLinkInMCJIT void)
(c-call ExternLLVMInitializeNativeTarget void) ; todo inlining does not work :(
(c-call ExternLLVMInitializeNativeAsmPrinter void) 

(def ee (c-ref))

(if (= 0 (c-call LLVMCreateJITCompilerForModule int * (c-ref ee) * m int 0 * (c-ref err)))
    nil
    (print (c-str err)))

(def plus (c-call LLVMGetPointerToGlobal * * ee * f))

(print 'calling ' plus)

(print '3 + 4 = ' (c-call * plus int int 3 int 4))

(print '
')

(def to-list
  (fn (string)

    (def to-list^
      (fn (pos rec)
        ((fn (c) (if (= c '') () (cons c (rec (+ pos 1) rec))))
         (substr string pos 1))))

    (to-list^ 0 to-list^)))

(def OP '(') ; ) (
(def CP ')')

(def newline '
')
(def whitespace (str ' 	' newline))
(def digit '0123456789')

(def nil? (fn (w) (if w nil '')))
(def not  (fn (c) (if c nil '')))

(def empty? (fn (l) (nil? (tail l))))

(def reduce
  (fn (f i l)
    (def reduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (f (rec res (tail ll) rec) (head ll)))))

    (reduce^ i l reduce^)))

(def leduce
  (fn (f i l)
    (def leduce^
      (fn (res ll rec)
        (if (empty? ll)
          res
          (rec (f res (head ll)) (tail ll) rec))))

    (leduce^ i l leduce^)))

(def listlen
  (fn (l)
    (leduce (fn (res i) (+ 1 res)) 0 l)))

(def strlen
  (fn (s) (listlen (to-list s))))

(def reverse
  (fn (l)
    (leduce (fn (res i) (cons i res)) () l)))

(def filter
  (fn (p l)
    (reduce 
      (fn (res i)
        (if (p i) (cons i res) res))
      ()
      l)))

(def map
  (fn (t l)
    (reduce
      (fn (res i)
        (cons (t i) res))
      ()
      l)))

(def in-list
  (fn (e l)
    (not (empty? (filter (fn (i) (= i e)) l)))))   

(def in-str
  (fn (c string) (in-list c (to-list string))))

(def is-whitespace
  (fn (x) (in-str x whitespace)))
(def is-newline
  (fn (x) (in-str x newline)))
(def not-is-newline
  (fn (x) (not (is-newline x))))
(def is-digit
  (fn (x) (in-str x digit)))

(def t-ws
  (fn (x) (if (is-whitespace x) '_' x)))

(def drop-while 
  (fn (p l)
    
    (def drop-while^
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (rec (tail ll) rec)
            ll))))

    (drop-while^ l drop-while^)))

(def take-while
  (fn (p l)
    
    (def take-while^ 
      (fn (ll rec)
        (if (empty? ll)
          ll
          (if (p (head ll))
            (cons (head ll) (rec (tail ll) rec))
            ()))))

    (take-while^ l take-while^)))

(def assoc 
 (fn (m k v)
  (cons k (cons v m))))

(def getk
 (fn (m k)
   (def getk^
     (fn (mm rec)
       (if (empty? mm)
         nil
         (if (= k (head mm))
            (head (tail mm))
            (rec (tail (tail mm)) rec)))))

   (getk^ m getk^)))

(print (getk () 'test') newline) ; should be nil
(def testmap (assoc (assoc (assoc () 'a' 1) 'b' 2) 'a' 3))
(print (getk testmap 'a') newline) ; should be 3
(print (getk testmap 'b') newline) ; should be 2

(def pair
  (fn (l r)
    (cons l (cons r))))


(def parse-sym 
  (fn (cs prs)
    (def sym-char
      (fn (c) (not (in-str c (str whitespace CP OP '\';')))))

    (pair 
      (symbol (str (take-while sym-char cs)))
      (drop-while sym-char cs))))

(def digit-to-number
  (fn (d)
    (if (= d '0') 0
    (if (= d '1') 1
    (if (= d '2') 2
    (if (= d '3') 3
    (if (= d '4') 4
    (if (= d '5') 5
    (if (= d '6') 6
    (if (= d '7') 7
    (if (= d '8') 8
    (if (= d '9') 9
    nil))))))))))))

(def parse-number
  (fn (cs prs)
    (def dec (take-while is-digit cs))
    (def r   (drop-while is-digit cs))
    
    (def rr  (if (empty? r) 
               r 
               (if (= '.' (head r)) 
                (tail r)
                r)))

    (def com (take-while is-digit rr))
    (def rrr (drop-while is-digit rr))

    (def n   (fn (l) (leduce (fn (nn dd) (+ (digit-to-number dd) (* 10 nn))) 0 l)))
    (def m   (fn (l) (leduce (fn (nn dd) (* 10 nn)) 1 l)))

    (pair (+ (n dec) (* (n com) (/ (m com)))) rrr)))
    
(def err (fn (x m) (print m newline) (pair (cons nil) x)))

(def parse-list 
  (fn (cs prs)
    (def parse-list^
      (fn (ccs rec)
        
        ((fn (p)
          (if (nil? p)
            (err ccs 'unexpected eof during list')
            ((fn (t r)
              (if (nil? t) ; end of list maybe?
                (if (empty? r)
                  (err ccs 'missing end of list')
                  (if (= CP (head r))
                    (pair () (tail r))
                    (err ccs (str 'unexpected: ' (head r)))))
                ((fn (pp)
                ((fn (tt rr)
                  (pair (cons t tt) rr)
                )(head pp)(head (tail pp)))
                )(rec r rec)))
            )(head p)(head (tail p))))
        )(prs ccs prs))))

      (parse-list^ (tail cs) parse-list^)))

(def parse-string
  (fn (cs rec)
    (def pcons
      (fn (i p)
        (def f (head p))
        (def s (head (tail p)))

        (if f 
          (pair (cons i f) s)
          p)))

    (def escape 
      (fn (escape-next ccs rec)
        (if (empty? ccs)
          (err ccs 'unexpected eof during string')
          (if escape-next
            (pcons (head ccs) (rec nil (tail ccs) rec))
            (if (= '\\' (head ccs))
              (rec '' (tail ccs) rec)
              (if (= '\'' (head ccs))
                (pair () (tail ccs))
                (pcons (head ccs) (rec nil (tail ccs) rec))))))))

    (def e (escape nil (tail cs) escape))
    
    (def f (head e))
    (def s (head (tail e)))

    (pair (str f) s)))

(def parse-expr
  (fn (cs rec)
    (if (empty? cs)
      nil
      ((fn (c)
        (if (is-whitespace c) (rec (drop-while is-whitespace cs) rec)
        (if (= c ';') (rec (drop-while not-is-newline cs) rec)
        (if (= c OP) (parse-list cs rec)
        (if (= c CP) (pair nil cs)
        (if (= c '\'') (parse-string cs rec)
        (if (is-digit c) (parse-number cs rec)
        (parse-sym cs rec)
        ))))))
      )(head cs)))))


(def parse-all
  (fn (cs rec)
    ((fn (p)
    (if (nil? p)
      ()
      ((fn (t r)
        (if (nil? t)
          (cons t)
          (cons t (rec r rec)))
      )(head p)(head (tail p)))
    )
    )(parse-expr cs parse-expr))))

(def code (parse-all (to-list INPUT) parse-all))

(print code)

(def is-number (fn (o) (= o (+ o))))
(def is-string (fn (o) (= o (str o))))
(def is-symbol (fn (o) (= o (symbol (symbol-name o)))))
(def is-list (fn (o) (if (= o ()) o (tail o))))
(def is-fn (fn (o) (if o (not (= o o)) o)))

(def c (c-call LLVMGetGlobalContext *))
(def m (c-call LLVMModuleCreateWithNameInContext * * 'real' * c))
(def int-type (c-call LLVMInt64TypeInContext * * c))
(def num-type (c-call LLVMDoubleTypeInContext * * c))
(def value-type (c-call LLVMStructCreateNamed * * c * 'value_type'))
(c-call LLVMStructSetBody void * value-type * (c-array int-type int-type) int 2 int 0)
(def ptr-type (c-call LLVMInt32TypeInContext * * c))
(def void-type (c-call LLVMVoidTypeInContext * * c))

(def main-f-type (c-call LLVMFunctionType * * void-type * (c-array) int 0 int 0))
(def main-f (c-call LLVMAddFunction * * m * 'start' * main-f-type))
(def main-bb (c-call LLVMAppendBasicBlockInContext * * c * main-f * 'entry'))
(def main-b (c-call LLVMCreateBuilder *))
(c-call LLVMPositionBuilderAtEnd void * main-b * main-bb)
;(def r (c-call LLVMBuildNSWAdd * * b * (c-call LLVMGetParam * * f int 0) * (c-call LLVMGetParam * * f int 1) * ''))

(def state-mk (fn (cur-val global-names) (cons cur-val (cons global-names))))
(def state-cur-val (fn (s) (head s)))
(def state-global-names (fn (s) (head (tail s))))
(def init-state (fn () (state-mk nil ())))

(def tr-number (fn (number state)
  (def set-type 
    (c-call LLVMBuildInsertValue * 
            * main-b
            * (c-call LLVMGetUndef * * value-type)
            * (c-call LLVMConstInt * * int-type int 1 int 1) ; type 1 = number
            int 0
            * 'set-type'))
  (def set-value
    (c-call LLVMBuildInsertValue *
            * main-b
            * set-type
            * (c-call LLVMBuildBitCast * * main-b * (c-call LLVMConstReal * * num-type double number) * int-type * 'pack dbl')
            int 1
            * 'set-value'))
  (state-mk set-value (state-global-names state))))

(def tr-default (fn (state) (tr-number 1337 state)))

(def tr-string (fn (string state)
 (def strval
   (c-call LLVMConstStringInContext * 
    * c
    * string
    int (+ (strlen string) 1)
    int 1)) ; do not zero terminate
 (def strmem
   (c-call LLVMAddGlobal *
    * m
    * (c-call LLVMTypeOf * * strval)
    * ''))
 (c-call LLVMSetGlobalConstant void * strmem int 1)
 (c-call LLVMSetInitializer void * strmem * strval)
 (state-mk
  (c-call LLVMConstNamedStruct *
    * value-type
    * (c-array
        (c-call LLVMConstInt * * int-type int 2 int 1) ; type 2 = string
        (c-call LLVMBuildPtrToInt *
         * main-b
         * (c-call LLVMBuildInBoundsGEP *
            * main-b
            * strmem
            * (c-array (c-call LLVMConstInt * * int-type int 0 int 1))
            int 1
            * 'str to ptr')
         * int-type
         * 'ptr to int'))
    int 2)
  (state-global-names state))))

(def tr-form
 (fn (form state tr)
   (def glb-nms (state-global-names state))

   (if (= (symbol 'def') (head form))
     (do
       (def name (head (tail form)))
       (def glb-nms^ 
          (if (getk glb-nms name)
            glb-nms
            (assoc glb-nms name 
              (c-call LLVMAddGlobal * * m * value-type * (symbol-name (head (tail form)))))))

       (def gl-var (getk glb-nms^ name))
       
       (def val (head (tail (tail form))))


       (def state^ 
         (tr (cons val) (state-mk nil glb-nms^) tr))

       (c-call LLVMBuildStore * * main-b * (state-cur-val state^) * gl-var)

       state^)
     (tr-default state))))

(def tr
  (fn (c)

    (def tr^ (fn (c state rec)
      (if (empty? c)
       state
       ((fn (h t)
         (def state
            (if (is-list h)
             (tr-form h state rec)
            (if (is-string h)
             (tr-string h state)
            (if (is-number h)
             (tr-number h state)
             (tr-default state))))) ; todo other options
         (rec t state rec)
       ) (head c) (tail c)))))

    (tr^ c (init-state) tr^)))

(tr code)

(c-call LLVMBuildRetVoid * * main-b)

(def LLVMAbortProcessAction 0)
(def LLVMPrintMessageAction 1)
(def LLVMReturnStatusAction 2)

(def err (c-ref))

(if (= 0 (c-call LLVMVerifyModule int * m int LLVMPrintMessageAction * (c-ref err)))
    nil
    (print (c-str err)))

(c-call LLVMDisposeBuilder void * main-b)

(print '
')
(c-call LLVMDumpModule void * m)

