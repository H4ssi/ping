
(print 'hello world!');
(c-call puts int * 'hello world from c puts call!')

(def hello (fn () (print 1)))

(hello)

; do some tests, check exit code

(def nil (cons))
(def failed-tests 0)
(def num-tests 0)

(def not (fn (c) (if c nil '')))

(def test (macro (cond descr)
           (cons (quote do)
           (cons (cons (quote def) (cons (quote num-tests) (cons (cons (quote +) (cons (quote num-tests) (cons 1))))))
           (cons
             (cons (quote if)
             (cons cond
             (cons nil
             (cons (cons (quote do)
                   (cons (cons (quote print) (cons descr))
                   (cons (cons (quote def) (cons (quote failed-tests) (cons (cons (quote +) (cons (quote failed-tests) (cons 1))))))
             ))))))))))))

(test (not nil) 'negation')
(test (not (not 1)) 'double negation')
(def var 1337)
(test (= var var) 'refs are equal')
(test (= 1337 1337) 'numbers are equal')
(test (not (= 1337 1338)) 'numbers are not equal')
(test (= 'hello' 'hello') 'strings are equal')
(test (not (= 'hello' 'goodbye')) 'strings are not equal')
(test (= (quote hello) (quote hello)) 'symbols are equal')
(test (not (= (quote hello) (quote goodbye))) 'symbols are not equal')
(test (not (= hello hello)) 'fns are never equal')
(test (= () ()) 'empty lists are equal')
(test (= (cons 1) (cons 1)) 'lists are equal')
(test (not (= () (cons 1))) 'lists are not equal')
(test (not (= 1 "1")) 'different types are not equal')

(def double (fn (x) (+ x x)))

(test (= (double (+ 1 1)) 4) 'double fn works')

(def rec (fn (limit rr)
           (if (= limit 0)
             0
             (+ limit (rr (+ limit (- 1)) rr)))))

(test (= (rec 5 rec) 15) 'recursion works')

(print (fn () 1))

(test (= (quote a) (symbol 'a')) 'symbol quoting works')
(test (= (quote 1337) 1337) 'number quoting works')
(test (= (quote 'text') 'text') 'text quoting works')
(test (= (quote (a 1 c)) (cons (symbol 'a') (cons 1 (cons (symbol 'c'))))) 'list quoting works')

(print 'over \'n out')
(print '\\./\'\\./\'\\./\'\\')

(test (= (symbol-name (quote hihi)) 'hihi') 'symbol-name fn works')

(def nil? (fn (t) (if t nil 1)))

(test (nil? (cons)) 'cons only results in nil')
(test () 'empty list is not nil')
(test (nil? (tail ())) 'tail of empty list is nil')
(test (head (cons 'asdf')) 'cons with one arg is single elem list')
(test (tail (cons 'asdf')) 'tail on single elem list is empty list')
(test (nil? (tail ())) 'tail on empty list is nil')
(test (= 1 (head (tail (tail (cons 2 (cons 2 (cons 1))))))) 'push and pop from list')
(test (tail (tail (tail (quote (a a a))))) 'calling tails first leads to empty list')
(test (nil? (tail (tail (tail (tail (quote a a a)))))) 'calling tails then leads to nil')

(def twice (macro (cmd) 
    (cons (quote do) 
    (cons cmd 
    (cons cmd)))))

(def dbl 'Na')

(twice (twice (twice (print dbl)))) ; do not print this here (print 'lel')
(print ' Batman!')

(test (= (str 1 2 3 'a' 'b' 'c' (quote d) (quote e) (quote f)) '123abcdef') 'str concat works')
(test (= (substr 'asdf') 'asdf') 'substr with string only')
(test (= (substr 'asdf' 2) 'df') 'substr with start only')
(test (= (substr 'asdf' 4) '') 'substr with start = length')
(test (= (substr 'asdf' 0 2) 'as') 'substr grep prefix')
(test (= (substr 'asdf' 2 0) '') 'substr grep 0 length')
(test (= (substr 'asdf' 2 20) 'df') 'substr grep beyond length')

(print (str 'tests: ' num-tests))

failed-tests

; this is a comment, should do nothing (print 1)
