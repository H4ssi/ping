
(print 'hello world!');

(def hello (fn () (print 1)))

(hello)

; do some tests, check exit code

(def nil (cons))
(def failed-tests 0)

(def not (fn (c) (if c nil '')))

(def test (macro (cond descr)
             (cons (quote if)
             (cons cond
             (cons nil
             (cons (cons (quote do)
                   (cons (cons (quote print) (cons descr))
                   (cons (cons (quote def) (cons (quote failed-tests) (cons (cons (quote +) (cons (quote failed-tests) (cons 1))))))
             )))))))))

(test (not nil) 'negation')
(test (not (not 1)) 'double negation')
(test (= 1337 1337) 'numbers are equal')

(def double (fn (x) (+ x x)))

(test (= (double (+ 1 1)) 4) 'double fn works')

(def rec (fn (limit rr)
           (if (= limit 0)
             0
             (+ limit (rr (+ limit (- 1)) rr)))))

(test (= (rec 5 rec) 15) 'recursion works')

(print (fn () 1))

(print (quote a) (quote 1337) (quote (a 1 c)))

(print 'over \'n out')
(print '\\./\'\\./\'\\./\'\\')

(print (symbol-name (quote hihi)))
(print (symbol 'hoho'))

(def nil? (fn (t) (if t nil 1)))

(test (nil? (cons)) 'cons only results in nil')
(test () 'empty list is not nil')
(test (nil? (tail ())) 'tail of empty list is nil')
(test (head (cons 'asdf')) 'cons with one arg is single elem list')
(test (tail (cons 'asdf')) 'tail on single elem list is empty list')
(test (nil? (tail ())) 'tail on empty list is nil')
(test (= 1 (head (tail (tail (cons 2 (cons 2 (cons 1))))))) 'push and pop from list')
(test (tail (tail (tail (quote (a a a))))) 'calling tails first leads to empty list')
(test (nil? (tail (tail (tail (tail (quote a a a)))))) 'calling tails then leads to nil')

(def twice (macro (cmd) 
    (cons (quote do) 
    (cons cmd 
    (cons cmd)))))

(def dbl '<dbl>')

(twice (print dbl)) ; do not print this here (print 'lel')

(print (str 1 2 3 'a' 'b' 'c' (quote d) (quote e) (quote f)))

failed-tests

; this is a comment, should do nothing (print 1)
